/**
 * Input schema for creating a new signature. The parameters vary based on the signature type.
 */
type CreateSignatureRequestDto = {
    type: 'evm-message';
    /**
     * Parameters for an EVM signature
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
        /**
         * Signer Locator
         * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
         */
        signer?: string;
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
} | {
    type: 'solana-message';
    /**
     * Parameters for a Solana signature
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
    };
} | {
    type: 'evm-typed-data';
    /**
     * Parameters for an EVM typed data signature
     */
    params: {
        typedData: {
            domain: {
                name: string;
                version: string;
                chainId: number;
                /**
                 * An EVM address string
                 */
                verifyingContract: string;
                salt?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {
                [key: string]: unknown;
            };
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        /**
         * Signer Locator
         * The locator for the signer who will approve this signature
         */
        signer?: string;
        /**
         * Whether the signature corresponds to the smart wallet or to the signer. Defaults to true (smart wallet signature wrapped with ERC6492). Set to false for signer signature.
         */
        isSmartWalletSignature?: boolean;
    };
};
/**
 * Input schema for creating a new signature. The parameters vary based on the signature type.
 */
type CreateSignatureV2025Dto = {
    type: 'message';
    /**
     * Parameters for a message signature
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
        /**
         * Signer Locator
         * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
         */
        signer?: string;
        /**
         * The chain on which the signature will be submitted. Required for EVM wallets, optional for others.
         */
        chain?: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
} | {
    type: 'typed-data';
    /**
     * Parameters for a typed data signature
     */
    params: {
        typedData: {
            domain: {
                name: string;
                version: string;
                chainId: number;
                /**
                 * An EVM address string
                 */
                verifyingContract: string;
                salt?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {
                [key: string]: unknown;
            };
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        /**
         * Signer Locator
         * The locator for the signer who will approve this signature
         */
        signer?: string;
        /**
         * Whether the signature corresponds to the smart wallet or to the signer. If true, the signature will be wrapped with ERC6492.
         */
        isSmartWalletSignature?: boolean;
    };
};
type CreateSignerInputDto = {
    /**
     * The locator of the delegated signer
     */
    signer: string | {
        /**
         * Identifier for the Passkey signer type
         */
        type: 'evm-passkey';
        /**
         * Credential ID from the WebAuthn registration response
         */
        id: string;
        /**
         * Human-readable name for the passkey
         */
        name: string;
        /**
         * The public key coordinates from the WebAuthn credential
         */
        publicKey: {
            /**
             * X coordinate of the public key as a string representation of a bigint
             */
            x: string;
            /**
             * Y coordinate of the public key as a string representation of a bigint
             */
            y: string;
        };
    };
    /**
     * The chain where the signer will be registered
     */
    chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
    /**
     * The expiry date of the signer in milliseconds since UNIX epoch
     */
    expiresAt?: number;
    /**
     * The permissions of the signer following ERC-7715
     */
    permissions?: Array<{
        type: 'native-token-transfer';
        data: {
            allowance: string;
        };
    } | {
        type: 'erc20-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            allowance: string;
        };
    } | {
        type: 'erc721-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs that can be transferred
             */
            tokenIds: Array<string>;
        };
    } | {
        type: 'erc1155-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs and allowances that can be transferred
             */
            allowances: {
                [key: string]: string;
            };
        };
    } | {
        type: 'gas-limit';
        data: {
            limit: string;
            enforcePaymaster?: boolean;
            allowedPaymaster?: string;
        };
    } | {
        type: 'call-limit';
        data: {
            count: number;
        };
    } | {
        type: 'rate-limit';
        data: {
            count: number;
            /**
             * Time window in seconds
             */
            interval: number;
        };
    }>;
} | {
    /**
     * Signer Locator
     * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
     */
    signer: string;
} | {
    /**
     * Signer Locator
     * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
     */
    signer: string;
};
type CreateSignerV2025InputDto = {
    signer: {
        /**
         * Identifier for the Passkey signer type
         */
        type: 'passkey';
        /**
         * Credential ID from the WebAuthn registration response
         */
        id: string;
        /**
         * Human-readable name for the passkey
         */
        name: string;
        /**
         * The public key coordinates from the WebAuthn credential
         */
        publicKey: {
            /**
             * X coordinate of the public key as a decimal string
             */
            x: string;
            /**
             * Y coordinate of the public key as a decimal string
             */
            y: string;
        };
    } | {
        /**
         * Identifier for API key signer type
         */
        type: 'api-key';
    } | {
        /**
         * Identifier for external wallet signer type
         */
        type: 'external-wallet';
        /**
         * The blockchain address of the external wallet
         */
        address: string;
    } | {
        /**
         * Identifier for email signer type
         */
        type: 'email';
        /**
         * The email address for the signer
         */
        email: string;
    } | {
        /**
         * Identifier for phone signer type
         */
        type: 'phone';
        /**
         * The phone number for the signer in E164 format
         */
        phone: string;
    } | string;
    /**
     * The chain where the signer will be registered
     */
    chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
    /**
     * The expiry date of the signer in ISO 8601 format
     */
    expiresAt?: number;
} | {
    /**
     * Signer Locator
     * A signer locator that can be either a of format '<signerAddress>' for external wallet type signers or '<signerType>:<signerIdentifier>'
     */
    signer: string;
} | {
    /**
     * Signer Locator
     * A signer locator that can be either a of format '<signerAddress>' for external wallet type signers or '<signerType>:<signerIdentifier>'
     */
    signer: string;
};
/**
 * Input schema for creating a new transaction. The parameters vary based on the wallet type (EVM vs Solana vs Stellar).
 */
type CreateTransactionDto = {
    /**
     * Solana smart wallet
     * Parameters for a transaction from a Solana Smart Wallet
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
    };
} | {
    /**
     * EVM smart wallet
     * Parameters for a transaction from an EVM Smart Wallet
     */
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * Serialized EVM transaction
             */
            transaction: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction
         */
        signer?: string;
    };
} | {
    /**
     * Solana MPC wallet
     * Parameters for a transaction from a Solana MPC Wallet
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
    };
} | {
    /**
     * EVM MPC wallet
     * Parameters for a transaction from an EVM MPC Wallet
     */
    params: {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
} | {
    /**
     * Stellar smart wallet
     * Parameters for a transaction from a Stellar Smart Wallet
     */
    params: {
        /**
         * Stellar transaction to execute
         */
        transaction: {
            /**
             * The type of transaction to execute
             */
            type: 'contract-call';
            /**
             * The recipient address for this transaction call
             */
            contractId: string;
            /**
             * The name of the function to call
             */
            method: string;
            /**
             * The memo for the transaction
             */
            memo?: {
                /**
                 * The type of memo
                 */
                type: 'text';
                /**
                 * The value of the memo (max 28 bytes)
                 */
                value: string;
            } | {
                /**
                 * The type of memo
                 */
                type: 'id';
                /**
                 * The value of the memo (64-bit unsigned integer)
                 */
                value: string;
            };
            /**
             * The arguments to pass to the function
             */
            args: {
                [key: string]: unknown;
            };
        } | {
            /**
             * The type of transaction to execute
             */
            type: 'serialized-transaction';
            /**
             * The XDR base64-encoded serialized transaction to execute
             */
            serializedTransaction: string;
            /**
             * The recipient address for this transaction call
             */
            contractId: string;
        };
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
    };
};
/**
 * Input schema for creating a new transaction. The parameters vary based on the wallet type (EVM vs Solana vs Stellar).
 */
type CreateTransactionV2025Dto = {
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
        /**
         * Signer Locator
         * A signer locator that can be either a of format '<signerAddress>' for external wallet type signers or '<signerType>:<signerIdentifier>'
         */
        signer?: string;
    };
} | {
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
    };
} | {
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * Serialized EVM transaction
             */
            transaction: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction
         */
        signer?: string;
    };
} | {
    /**
     * EVM MPC wallet
     * Parameters for a transaction from an EVM MPC Wallet
     */
    params: {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
} | {
    /**
     * Stellar smart wallet
     * Parameters for a transaction from a Stellar Smart Wallet
     */
    params: {
        /**
         * Stellar transaction to execute
         */
        transaction: {
            /**
             * The type of transaction to execute
             */
            type: 'contract-call';
            /**
             * The recipient address for this transaction call
             */
            contractId: string;
            /**
             * The name of the function to call
             */
            method: string;
            /**
             * The memo for the transaction
             */
            memo?: {
                /**
                 * The type of memo
                 */
                type: 'text';
                /**
                 * The value of the memo (max 28 bytes)
                 */
                value: string;
            } | {
                /**
                 * The type of memo
                 */
                type: 'id';
                /**
                 * The value of the memo (64-bit unsigned integer)
                 */
                value: string;
            };
            /**
             * The arguments to pass to the function
             */
            args: {
                [key: string]: unknown;
            };
        } | {
            /**
             * The type of transaction to execute
             */
            type: 'serialized-transaction';
            /**
             * The XDR base64-encoded serialized transaction to execute
             */
            serializedTransaction: string;
            /**
             * The recipient address for this transaction call
             */
            contractId: string;
        };
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
    };
};
type CreateWalletDto = {
    type: 'evm-smart-wallet';
    config?: {
        adminSigner: {
            /**
             * Identifier for EVM keypair signer type
             */
            type: 'evm-keypair';
            /**
             * The Ethereum address of the external signer
             */
            address: string;
        } | {
            /**
             * Identifier for EVM Fireblocks custodial signer type
             */
            type: 'evm-fireblocks-custodial';
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'evm-passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a string representation of a bigint
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a string representation of a bigint
                 */
                y: string;
            };
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
        };
        /**
         * Optional array of delegated signers to be created for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * The locator of the delegated signer
             */
            signer: string | {
                /**
                 * Identifier for the Passkey signer type
                 */
                type: 'evm-passkey';
                /**
                 * Credential ID from the WebAuthn registration response
                 */
                id: string;
                /**
                 * Human-readable name for the passkey
                 */
                name: string;
                /**
                 * The public key coordinates from the WebAuthn credential
                 */
                publicKey: {
                    /**
                     * X coordinate of the public key as a string representation of a bigint
                     */
                    x: string;
                    /**
                     * Y coordinate of the public key as a string representation of a bigint
                     */
                    y: string;
                };
            };
            /**
             * The expiry date of the signer in milliseconds since UNIX epoch
             */
            expiresAt?: number;
            /**
             * The permissions of the signer following ERC-7715
             */
            permissions?: Array<{
                type: 'native-token-transfer';
                data: {
                    allowance: string;
                };
            } | {
                type: 'erc20-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    allowance: string;
                };
            } | {
                type: 'erc721-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    /**
                     * The token IDs that can be transferred
                     */
                    tokenIds: Array<string>;
                };
            } | {
                type: 'erc1155-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    /**
                     * The token IDs and allowances that can be transferred
                     */
                    allowances: {
                        [key: string]: string;
                    };
                };
            } | {
                type: 'gas-limit';
                data: {
                    limit: string;
                    enforcePaymaster?: boolean;
                    allowedPaymaster?: string;
                };
            } | {
                type: 'call-limit';
                data: {
                    count: number;
                };
            } | {
                type: 'rate-limit';
                data: {
                    count: number;
                    /**
                     * Time window in seconds
                     */
                    interval: number;
                };
            }>;
        }>;
        /**
         * The unique wallet seed. By default, the seed is randomly generated.
         */
        creationSeed?: string;
    };
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'solana-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'solana-smart-wallet';
    config?: {
        adminSigner?: {
            /**
             * Identifier for Solana keypair signer type
             */
            type: 'solana-keypair';
            /**
             * The Solana public key (base58 encoded) of the external signer
             */
            address: string;
        } | {
            /**
             * Identifier for Solana Fireblocks MPC signer type
             */
            type: 'solana-fireblocks-custodial';
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
        };
        /**
         * Optional array of delegated signers to be created for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Signer Locator
             * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
             */
            signer: string;
        }>;
    };
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'aptos-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'sui-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'solana-custodial-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
} | {
    type: 'evm-mpc-wallet';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    linkedUser?: string;
};
type CreateWalletV2025Dto = {
    chainType: 'evm';
    type?: 'smart' | 'mpc';
    config?: {
        adminSigner: {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
        };
        /**
         * Optional array of delegated signers to be created for the wallet
         */
        delegatedSigners?: Array<{
            signer: {
                /**
                 * Identifier for the Passkey signer type
                 */
                type: 'passkey';
                /**
                 * Credential ID from the WebAuthn registration response
                 */
                id: string;
                /**
                 * Human-readable name for the passkey
                 */
                name: string;
                /**
                 * The public key coordinates from the WebAuthn credential
                 */
                publicKey: {
                    /**
                     * X coordinate of the public key as a decimal string
                     */
                    x: string;
                    /**
                     * Y coordinate of the public key as a decimal string
                     */
                    y: string;
                };
            } | {
                /**
                 * Identifier for API key signer type
                 */
                type: 'api-key';
            } | {
                /**
                 * Identifier for external wallet signer type
                 */
                type: 'external-wallet';
                /**
                 * The blockchain address of the external wallet
                 */
                address: string;
            } | {
                /**
                 * Identifier for email signer type
                 */
                type: 'email';
                /**
                 * The email address for the signer
                 */
                email: string;
            } | {
                /**
                 * Identifier for phone signer type
                 */
                type: 'phone';
                /**
                 * The phone number for the signer in E164 format
                 */
                phone: string;
            } | string;
            /**
             * The expiry date of the signer in ISO 8601 format
             */
            expiresAt?: number;
        }>;
        /**
         * The unique wallet seed. By default, the seed is randomly generated.
         */
        creationSeed?: string;
    } | unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    owner?: string;
} | {
    chainType: 'solana';
    type?: 'smart' | 'mpc';
    config?: {
        adminSigner: {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
        };
        /**
         * Optional array of delegated signers to be created for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Signer Locator
             * A signer locator that can be either a of format '<signerAddress>' for external wallet type signers or '<signerType>:<signerIdentifier>'
             */
            signer: string;
        }>;
    } | unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    owner?: string;
} | {
    chainType: 'aptos';
    type?: 'mpc';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    owner?: string;
} | {
    chainType: 'sui';
    type?: 'mpc';
    config?: unknown;
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    owner?: string;
} | {
    chainType: 'stellar';
    type?: 'smart';
    config: {
        adminSigner: {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
        };
        /**
         * Optional array of delegated signers to be created for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Signer Locator
             * A signer locator that can be either a of format '<signerAddress>' for external wallet type signers or '<signerType>:<signerIdentifier>'
             */
            signer: string;
            /**
             * Optional array of permissions to be used for the signer
             */
            permissions?: Array<{
                type: 'external-policy';
                address: string;
            }>;
        }>;
        /**
         * Optional array of plugins to be used for the wallet
         */
        plugins?: Array<string>;
    };
    /**
     * A user locator can be of the format:
     * - `email:<email>`
     * - `userId:<userId>`
     * - `phoneNumber:<phoneNumber>`
     * - `twitter:<handle>`
     * - `x:<handle>`
     */
    owner?: string;
};
type DelegatedSignerDto = {
    /**
     * Specifies the type of EVM signer being used, describing the method of key management and transaction signing. `evm-keypair` indicates a signer using a locally managed keypair, suitable for non-custodial wallets. `evm-fireblocks-custodial` refers to a signer managed by Fireblocks, a custodial service provider.
     */
    type: 'evm-keypair' | 'evm-fireblocks-custodial' | 'evm-passkey';
    /**
     * Signer Locator
     * The locator of the signer
     */
    locator: string;
    /**
     * The expiry date of the signer in ISO 8601 format
     */
    expiresAt?: number;
    /**
     * The permissions of the signer following ERC-7715
     */
    permissions?: Array<{
        type: 'native-token-transfer';
        data: {
            allowance: string;
        };
    } | {
        type: 'erc20-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            allowance: string;
        };
    } | {
        type: 'erc721-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs that can be transferred
             */
            tokenIds: Array<string>;
        };
    } | {
        type: 'erc1155-token-transfer';
        data: {
            /**
             * The address of the smart contract that can be interacted with
             */
            address: string;
            /**
             * The token IDs and allowances that can be transferred
             */
            allowances: {
                [key: string]: string;
            };
        };
    } | {
        type: 'gas-limit';
        data: {
            limit: string;
            enforcePaymaster?: boolean;
            allowedPaymaster?: string;
        };
    } | {
        type: 'call-limit';
        data: {
            count: number;
        };
    } | {
        type: 'rate-limit';
        data: {
            count: number;
            /**
             * Time window in seconds
             */
            interval: number;
        };
    }>;
    /**
     * Authorization status for each chain where the chain name is the key and the signature request is the value
     */
    chains?: {
        [key: string]: {
            status: 'success';
        } | {
            status: 'pending' | 'awaiting-approval' | 'failed';
            /**
             * Unique identifier for the signature
             */
            id: string;
            /**
             * Complete approval data including requirements, pending and submitted signatures
             */
            approvals?: {
                /**
                 * List of pending signatures
                 */
                pending: Array<{
                    /**
                     * The locator of the signer that's pending approval
                     */
                    signer: string;
                    /**
                     * The message that needs to be signed
                     */
                    message: string;
                }>;
                /**
                 * Record of all submitted signatures
                 */
                submitted: Array<{
                    /**
                     * The cryptographic signature
                     */
                    signature: string;
                    /**
                     * When the signature was submitted
                     */
                    submittedAt: number;
                    /**
                     * Signer Locator
                     * The locator of the signer who submitted this signature
                     */
                    signer: string;
                    /**
                     * The message that was signed
                     */
                    message: string;
                    /**
                     * Additional metadata about the signature submission
                     */
                    metadata?: {
                        deviceInfo?: string;
                        ipAddress?: string;
                        userAgent?: string;
                    };
                }>;
                /**
                 * Number of required approvals for the transaction
                 */
                required?: number;
            };
        };
    };
} | {
    /**
     * Specifies the type of Solana signer being used, describing the method of key management and transaction signing.
     */
    type: 'solana-keypair' | 'solana-fireblocks-custodial';
    /**
     * The address of the signer
     */
    address: string;
    /**
     * Signer Locator
     * The locator of the signer
     */
    locator: string;
    /**
     * The transaction for the signer
     */
    transaction: {
        /**
         * Solana smart wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * Signer Locator
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    };
};
type DelegatedSignerV2025Dto = (({
    /**
     * Identifier for the Passkey signer type
     */
    type: 'passkey';
    /**
     * Credential ID from the WebAuthn registration response
     */
    id: string;
    /**
     * Human-readable name for the passkey
     */
    name: string;
    /**
     * The public key coordinates from the WebAuthn credential
     */
    publicKey: {
        /**
         * X coordinate of the public key as a decimal string
         */
        x: string;
        /**
         * Y coordinate of the public key as a decimal string
         */
        y: string;
    };
    /**
     * ERC-7579 webAuthn validator contract version
     */
    validatorContractVersion: string;
    /**
     * Unique identifier for locating this passkey signer
     */
    locator: string;
} | {
    /**
     * Identifier for API key signer type
     */
    type: 'api-key';
    /**
     * The blockchain address of the custodial signer
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
} | {
    /**
     * Identifier for external wallet signer type
     */
    type: 'external-wallet';
    /**
     * The blockchain address of the external wallet
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
} | {
    /**
     * Identifier for email signer type
     */
    type: 'email';
    /**
     * The email address for the signer
     */
    email: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The address of the signer
     */
    address: string;
} | {
    /**
     * Identifier for phone signer type
     */
    type: 'phone';
    /**
     * The phone number for the signer in E164 format
     */
    phone: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The address of the signer
     */
    address: string;
}) & {
    /**
     * The transaction for the signer
     */
    transaction?: {
        chainType: 'solana';
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
        walletType: 'smart';
    };
}) | (({
    /**
     * Identifier for the Passkey signer type
     */
    type: 'passkey';
    /**
     * Credential ID from the WebAuthn registration response
     */
    id: string;
    /**
     * Human-readable name for the passkey
     */
    name: string;
    /**
     * The public key coordinates from the WebAuthn credential
     */
    publicKey: {
        /**
         * X coordinate of the public key as a decimal string
         */
        x: string;
        /**
         * Y coordinate of the public key as a decimal string
         */
        y: string;
    };
    /**
     * ERC-7579 webAuthn validator contract version
     */
    validatorContractVersion: string;
    /**
     * Unique identifier for locating this passkey signer
     */
    locator: string;
} | {
    /**
     * Identifier for API key signer type
     */
    type: 'api-key';
    /**
     * The blockchain address of the custodial signer
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
} | {
    /**
     * Identifier for external wallet signer type
     */
    type: 'external-wallet';
    /**
     * The blockchain address of the external wallet
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
} | {
    /**
     * Identifier for email signer type
     */
    type: 'email';
    /**
     * The email address for the signer
     */
    email: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The address of the signer
     */
    address: string;
} | {
    /**
     * Identifier for phone signer type
     */
    type: 'phone';
    /**
     * The phone number for the signer in E164 format
     */
    phone: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The address of the signer
     */
    address: string;
}) & {
    /**
     * The expiry date of the signer in ISO 8601 format
     */
    expiresAt?: number | string;
    /**
     * Authorization status for each chain where the chain name is the key and the signature request is the value
     */
    chains?: {
        [key: string]: {
            status: 'success';
        } | {
            status: 'pending' | 'awaiting-approval' | 'failed';
            /**
             * Unique identifier for the signature
             */
            id: string;
            /**
             * Complete approval data including requirements, pending and submitted signatures
             */
            approvals?: {
                /**
                 * List of pending signatures
                 */
                pending: Array<{
                    /**
                     * The full signer object that's pending approval
                     */
                    signer: {
                        type: 'external-wallet';
                        /**
                         * The address of the external wallet
                         */
                        address: string;
                        /**
                         * The locator of the external wallet signer
                         */
                        locator: string;
                    } | {
                        type: 'passkey';
                        /**
                         * The ID of the passkey
                         */
                        id: string;
                        /**
                         * The locator of the passkey signer
                         */
                        locator: string;
                    } | {
                        type: 'api-key';
                        /**
                         * The address of the api key
                         */
                        address: string;
                        /**
                         * The locator of the api key signer
                         */
                        locator: string;
                    } | {
                        type: 'email';
                        email: string;
                        locator: string;
                    } | {
                        type: 'phone';
                        phone: string;
                        locator: string;
                    };
                    /**
                     * The message that needs to be signed
                     */
                    message: string;
                }>;
                /**
                 * Record of all submitted signatures
                 */
                submitted: Array<{
                    /**
                     * The cryptographic signature
                     */
                    signature: string;
                    /**
                     * When the signature was submitted
                     */
                    submittedAt: number | string;
                    /**
                     * The full signer object who submitted this signature
                     */
                    signer: {
                        type: 'external-wallet';
                        /**
                         * The address of the external wallet
                         */
                        address: string;
                        /**
                         * The locator of the external wallet signer
                         */
                        locator: string;
                    } | {
                        type: 'passkey';
                        /**
                         * The ID of the passkey
                         */
                        id: string;
                        /**
                         * The locator of the passkey signer
                         */
                        locator: string;
                    } | {
                        type: 'api-key';
                        /**
                         * The address of the api key
                         */
                        address: string;
                        /**
                         * The locator of the api key signer
                         */
                        locator: string;
                    } | {
                        type: 'email';
                        email: string;
                        locator: string;
                    } | {
                        type: 'phone';
                        phone: string;
                        locator: string;
                    };
                    /**
                     * The message that was signed
                     */
                    message: string;
                    /**
                     * Additional metadata about the signature submission
                     */
                    metadata?: {
                        deviceInfo?: string;
                        ipAddress?: string;
                        userAgent?: string;
                    };
                }>;
                /**
                 * Number of required approvals for the transaction
                 */
                required?: number;
            };
        };
    };
}) | (({
    /**
     * Identifier for the Passkey signer type
     */
    type: 'passkey';
    /**
     * Credential ID from the WebAuthn registration response
     */
    id: string;
    /**
     * Human-readable name for the passkey
     */
    name: string;
    /**
     * The public key coordinates from the WebAuthn credential
     */
    publicKey: {
        /**
         * X coordinate of the public key as a decimal string
         */
        x: string;
        /**
         * Y coordinate of the public key as a decimal string
         */
        y: string;
    };
    /**
     * ERC-7579 webAuthn validator contract version
     */
    validatorContractVersion: string;
    /**
     * Unique identifier for locating this passkey signer
     */
    locator: string;
} | {
    /**
     * Identifier for API key signer type
     */
    type: 'api-key';
    /**
     * The blockchain address of the custodial signer
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
} | {
    /**
     * Identifier for external wallet signer type
     */
    type: 'external-wallet';
    /**
     * The blockchain address of the external wallet
     */
    address: string;
    /**
     * The locator of the signer
     */
    locator: string;
} | {
    /**
     * Identifier for email signer type
     */
    type: 'email';
    /**
     * The email address for the signer
     */
    email: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The address of the signer
     */
    address: string;
} | {
    /**
     * Identifier for phone signer type
     */
    type: 'phone';
    /**
     * The phone number for the signer in E164 format
     */
    phone: string;
    /**
     * The locator of the signer
     */
    locator: string;
    /**
     * The address of the signer
     */
    address: string;
}) & {
    /**
     * Optional array of permissions to be used for the signer
     */
    permissions?: Array<{
        type: 'external-policy';
        address: string;
    }>;
    /**
     * The transaction for the signer
     */
    transaction?: {
        chainType: 'stellar';
        /**
         * Stellar on-chain data
         */
        onChain: {
            /**
             * Stellar on-chain transaction
             * The Stellar Transaction Envelope
             */
            transaction: {
                method: string;
                tx: string;
            };
            /**
             * The transaction hash
             */
            txId?: string;
            /**
             * The ledger number where the transaction was included
             */
            ledger?: number;
            /**
             * The expiration of the transaction
             */
            expiration: number;
            /**
             * The Transaction Result in XDR format
             */
            result?: unknown;
            /**
             * Optional link to view the transaction in an explorer
             */
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
        walletType: 'smart';
    };
});
/**
 * Parameters required to fund a wallet
 */
type FundWalletAmountDto = {
    /**
     * The amount of currency to fund the wallet with. Between 1 and 100
     */
    amount: number;
    /**
     * The currency to fund the wallet with
     */
    token: 'usdc' | 'usdxm';
    /**
     * The chain to fund the wallet with
     */
    chain?: 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'barret-testnet' | 'ethereum-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'sei-atlantic-2-testnet' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'viction-testnet' | 'solana' | 'stellar';
};
/**
 * Specific terms for a Story Protocol PIL (Programmable IP License). Default is the `Non-Commercial Social Remixing` license. More details here: https://docs.story.foundation/docs/pil-terms
 */
type SchemaHolderClass = Array<{
    /**
     * The License Terms ID
     */
    id: string;
    /**
     * The PIL terms details as per retrieved from story
     */
    terms: {
        /**
         * If false, the License Token cannot be transferred once it is minted to a recipient address
         */
        transferable: boolean;
        /**
         * The address of the royalty policy contract
         */
        royaltyPolicy: string;
        /**
         * The fee to be paid when minting a license
         */
        defaultMintingFee: number;
        /**
         * The expiration period of the license
         */
        expiration: number;
        /**
         * Determines if the licensee can make money from using the original IP Asset
         */
        commercialUse: boolean;
        /**
         * If true, people must give credit to the original work in their commercial application
         */
        commercialAttribution: boolean;
        /**
         * Commercializers that are allowed to commercially exploit the original work. If zero address, then no restrictions are enforced.
         */
        commercializerChecker: string;
        /**
         * The data to be passed to the commercializer checker contract.
         */
        commercializerCheckerData: string;
        /**
         * Amount of revenue (from any source, original & derivative) that must be shared with the licensor (a value of 10,000,000 == 10% of revenue share).
         */
        commercialRevShare: number;
        /**
         * Maximum revenue that can be earned from the original work if commercialUse is true
         */
        commercialRevCeiling: number;
        /**
         * Indicates whether the licensee can create derivatives of the work
         */
        derivativesAllowed: boolean;
        /**
         * If true, derivatives must give credit to the original work
         */
        derivativesAttribution: boolean;
        /**
         * If true, the licensor must approve derivatives of the work
         */
        derivativesApproval: boolean;
        /**
         * If true, derivatives must have the exact same terms
         */
        derivativesReciprocal: boolean;
        /**
         * Maximum revenue that can be earned from derivative works if commercialUse is true
         */
        derivativeRevCeiling: number;
        /**
         * The ERC20 token address to be used to pay the minting fee
         */
        currency: string;
        /**
         * URI containing additional license terms, will be overridden by the license terms in the metadata
         */
        uri: string;
    };
    /**
     * If true, the license terms will be disabled. Effectively preventing future mints with this license.
     */
    disabled?: boolean;
}>;
type SendOrDepositTokenV2025Dto = {
    /**
     * An address locator that supports different types of recipients. It can be of the format:
     * - `<address>` (wallet address)
     * - `chain:address` (e.g. ethereum:0x1234...)
     * - `address:<blockchain_address>[:chain]`
     * - `email:<email_address>[:chain]`
     * - `phoneNumber:<phone_number>[:chain]`
     * - `twitter:<twitter_handle>[:chain]`
     * - `x:<twitter_handle>[:chain]`
     * - `userId:<user_id>[:chain]`
     */
    recipient: string;
    /**
     * Signer Locator
     * Optional signer locator. Defaults to admin signer
     */
    signer?: string;
    /**
     * Amount of tokens to transfer (in decimal value)
     */
    amount?: string;
    /**
     * Memo for the transaction. Only supported for Stellar
     */
    memo?: {
        /**
         * The type of memo
         */
        type: 'text';
        /**
         * The value of the memo (max 28 bytes)
         */
        value: string;
    } | {
        /**
         * The type of memo
         */
        type: 'id';
        /**
         * The value of the memo (64-bit unsigned integer)
         */
        value: string;
    };
} | {
    /**
     * Signer Locator
     * Optional signer locator. Defaults to admin signer
     */
    signer?: string;
    /**
     * Amount of tokens to transfer (in decimal value)
     */
    amount: string;
    /**
     * Memo for the transaction. Only supported for Stellar
     */
    memo?: {
        /**
         * The type of memo
         */
        type: 'text';
        /**
         * The value of the memo (max 28 bytes)
         */
        value: string;
    } | {
        /**
         * The type of memo
         */
        type: 'id';
        /**
         * The value of the memo (64-bit unsigned integer)
         */
        value: string;
    };
    recipient: string;
};
type SendTokenDto = {
    /**
     * An address locator that supports different types of recipients. It can be of the format:
     * - `<address>` (wallet address)
     * - `chain:address` (e.g. ethereum:0x1234...)
     * - `address:<blockchain_address>[:chain]`
     * - `email:<email_address>[:chain]`
     * - `phoneNumber:<phone_number>[:chain]`
     * - `twitter:<twitter_handle>[:chain]`
     * - `x:<twitter_handle>[:chain]`
     * - `userId:<user_id>[:chain]`
     */
    recipient: string;
    /**
     * Signer Locator
     * Optional signer locator. Defaults to admin signer
     */
    signer?: string;
    /**
     * Amount of tokens to transfer (in decimal format)
     */
    amount?: string;
};
/**
 * Base fields for all token transfers
 */
type SendTokenV2025Dto = {
    /**
     * An address locator that supports different types of recipients. It can be of the format:
     * - `<address>` (wallet address)
     * - `chain:address` (e.g. ethereum:0x1234...)
     * - `address:<blockchain_address>[:chain]`
     * - `email:<email_address>[:chain]`
     * - `phoneNumber:<phone_number>[:chain]`
     * - `twitter:<twitter_handle>[:chain]`
     * - `x:<twitter_handle>[:chain]`
     * - `userId:<user_id>[:chain]`
     */
    recipient: string;
    /**
     * Signer Locator
     * Optional signer locator. Defaults to admin signer
     */
    signer?: string;
    /**
     * Amount of tokens to transfer (in decimal value)
     */
    amount?: string;
    /**
     * Memo for the transaction. Only supported for Stellar
     */
    memo?: {
        /**
         * The type of memo
         */
        type: 'text';
        /**
         * The value of the memo (max 28 bytes)
         */
        value: string;
    } | {
        /**
         * The type of memo
         */
        type: 'id';
        /**
         * The value of the memo (64-bit unsigned integer)
         */
        value: string;
    };
};
/**
 * Input for submitting one or more approvals
 */
type SubmitApprovalDto = {
    /**
     * Array of approvals to submit for this transaction
     */
    approvals: Array<{
        /**
         * The locator for the EVM signer
         */
        signer: string;
        /**
         * The EVM cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the EVM signer
         */
        signer: string;
        /**
         * The signature components
         */
        signature: {
            /**
             * R component of the signature as a string representation of a bigint
             */
            r: string;
            /**
             * S component of the signature as a string representation of a bigint
             */
            s: string;
        };
        /**
         * WebAuthn signature metadata
         */
        metadata: {
            /**
             * WebAuthn authenticator data as hex string
             */
            authenticatorData: string;
            /**
             * Index of the challenge used
             */
            challengeIndex: number;
            /**
             * WebAuthn client data JSON string
             */
            clientDataJSON: string;
            /**
             * Index of the signature type
             */
            typeIndex: number;
            /**
             * Whether user verification was required
             */
            userVerificationRequired: boolean;
        };
    } | {
        /**
         * The locator for the email signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the phone signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    }> | Array<{
        /**
         * The locator for the Solana signer
         */
        signer: string;
        /**
         * The Solana cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the email signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the phone signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    }> | Array<{
        /**
         * The locator for the external wallet signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the email signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the phone signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    }>;
};
/**
 * Input for submitting one or more approvals
 */
type SubmitApprovalV2025Dto = {
    /**
     * Array of approvals to submit for this transaction
     */
    approvals: Array<{
        /**
         * The locator for the passkey signer
         */
        signer: string;
        /**
         * The signature components
         */
        signature: {
            /**
             * R component of the signature as a stringified bigint
             */
            r: string;
            /**
             * S component of the signature as a stringified bigint
             */
            s: string;
        };
        /**
         * WebAuthn signature metadata
         */
        metadata: {
            /**
             * WebAuthn authenticator data as hex string
             */
            authenticatorData: string;
            /**
             * Index of the challenge used
             */
            challengeIndex: number;
            /**
             * WebAuthn client data JSON string
             */
            clientDataJSON: string;
            /**
             * Index of the signature type
             */
            typeIndex: number;
            /**
             * Whether user verification was required
             */
            userVerificationRequired: boolean;
        };
    } | {
        /**
         * The locator for the external wallet signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the email signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    } | {
        /**
         * The locator for the phone signer
         */
        signer: string;
        /**
         * The cryptographic signature
         */
        signature: string;
    }>;
};
/**
 * The balances of the wallet
 */
type WalletBalanceResponseDto = Array<{
    /**
     * The token
     */
    token: 'ape' | 'bnb' | 'coti' | 'eth' | 'matic' | 'mnt' | 'pol' | 'sei' | 'chz' | 'avax' | 'xai' | 'fuel' | 'hbar' | 'vic' | 'ip' | 'zcx' | 'u2u' | 'flow' | 'usdc' | 'usdce' | 'busd' | 'usdxm' | 'usdt' | 'credit' | 'usdf' | 'weth' | 'degen' | 'brett' | 'toshi' | 'eurc' | 'superverse' | 'pirate' | 'wld' | 'bonk' | 'trump' | 'xmeme' | 'fartcoin' | 'clanker' | 'giga' | 'moodeng' | 'jailstool' | 'wen' | 'mlg' | 'duo' | 'pep' | 'harambe' | 'usedcar' | 'vine' | 'fartboy' | 'pnut' | 'stonks' | 'mew' | 'baby' | 'michi' | 'butthole' | 'anglerfish' | 'usa' | 'chillguy' | 'sigma' | 'maneki' | 'purpe' | 'lockin' | 'y2k' | 'fafo' | 'nub' | 'fullsend' | 'shoggoth' | 'mini' | 'llm' | 'sc' | 'fatgf' | 'pwease' | 'popcat' | 'spx' | 'fwog' | 'mother' | 'wif' | 'fric' | 'etf' | 'gyat' | 'bigballs' | 'goat' | 'stupid' | 'duko' | 'bitcoin' | 'buttcoin' | 'mcdull' | 'skbdi' | 'elon4afd' | 'mumu' | 'gme' | 'biao' | 'fred' | 'pengu' | 'asscoin' | 'bhad' | 'habibi' | 'quant' | 'hammy' | 'boden' | 'dolan' | 'nap' | 'scf' | 'titcoin' | 'zerebro' | 'rfc' | 'luce' | 'melania' | 'slerf' | 'bome' | 'ban' | 'pippin' | 'ghibli' | 'figure' | 'retardio' | 'memesai' | 'dogeai' | 'memecoin' | 'routine' | 'troll' | 'nobody' | 'italianrot' | 'jockey' | 'pppp' | 'useless' | 'gork' | 'hosico' | 'neet' | 'urmom' | 'bert' | 'fog' | 'mog' | 'boopa' | 'wizard' | 'trencher' | 'chacha' | 'labubu' | 'moonpig' | 'king' | 'hoodrat' | 'goonc' | 'gib' | 'assdaq' | 'xbt' | 'ripvc' | 'passroo' | 'buck' | 'chizzler' | 'kori' | 'cupsey' | 'grumpy' | 'aurafarm' | 'monkephone' | 'chillhouse' | 'aura' | 'usduc' | 'mask' | 'sugar' | 'dege' | 'aquarius' | 'aries' | 'cancer' | 'capricorn' | 'gemini' | 'leo' | 'libra' | 'pisces' | 'sagittarius' | 'scorpio' | 'taurus' | 'virgo' | 'ani' | 'blob' | 'boatkid' | 'ufd' | 'lizard' | 'tokabu' | 'worthless' | 'clippy' | 'nailong' | 'uranus' | 'usdm1' | 'sol' | 'sui' | 'apt' | 'sfuel' | 'xion' | 'xlm';
    /**
     * The number of decimals of the token
     */
    decimals: number;
    /**
     * The balance of the wallet in different chains
     */
    balances: {
        [key: string]: string;
    };
}>;
/**
 * Array of wallet balances per token
 */
type WalletBalanceUnstableResponseDto = Array<{
    symbol?: string;
    /**
     * The name of the token
     */
    name?: string;
    /**
     * The number of decimals of the token
     */
    decimals: number;
    /**
     * The amount of the token after placing the decimal point
     */
    amount: string;
    /**
     * The raw amount of the token
     */
    rawAmount: string;
    /**
     * Balance information per chain
     */
    chains: {
        [key: string]: {
            /**
             * Either a token string (e.g., 'eth', 'sol', 'xlm') or a token locator string (e.g., 'ethereum:0x123', 'stellar:xlm')
             */
            locator: string;
            /**
             * The amount of the token after placing the decimal point
             */
            amount: string;
            /**
             * The raw amount of the token
             */
            rawAmount: string;
            /**
             * The contract address of the token on the EVM chain. Not present for native tokens.
             */
            contractAddress?: string;
        } | {
            /**
             * Either a token string (e.g., 'eth', 'sol', 'xlm') or a token locator string (e.g., 'ethereum:0x123', 'stellar:xlm')
             */
            locator: string;
            /**
             * The amount of the token after placing the decimal point
             */
            amount: string;
            /**
             * The raw amount of the token
             */
            rawAmount: string;
            /**
             * The mint hash of the token on Solana. Not present for native SOL.
             */
            mintHash?: string;
        } | {
            /**
             * Either a token string (e.g., 'eth', 'sol', 'xlm') or a token locator string (e.g., 'ethereum:0x123', 'stellar:xlm')
             */
            locator: string;
            /**
             * The amount of the token after placing the decimal point
             */
            amount: string;
            /**
             * The raw amount of the token
             */
            rawAmount: string;
            /**
             * The contract ID of the token on Stellar. Not present for native XLM.
             */
            contractId?: string;
        };
    };
}>;
/**
 * Array of wallet balances per token
 */
type WalletBalanceV20250609ResponseDto = Array<{
    symbol?: string;
    /**
     * The name of the token
     */
    name?: string;
    /**
     * The number of decimals of the token
     */
    decimals: number;
    /**
     * The amount of the token after placing the decimal point
     */
    amount: string;
    /**
     * The raw amount of the token
     */
    rawAmount: string;
    /**
     * Balance information per chain
     */
    chains: {
        [key: string]: {
            /**
             * Either a token string (e.g., 'eth', 'sol') or a token locator string (e.g., 'ethereum:0x123', 'solana:sol')
             */
            locator: string;
            /**
             * The amount of the token after placing the decimal point
             */
            amount: string;
            /**
             * The raw amount of the token
             */
            rawAmount: string;
            /**
             * The contract address of the token on the EVM chain. Not present for native tokens.
             */
            contractAddress?: string;
        } | {
            /**
             * Either a token string (e.g., 'eth', 'sol') or a token locator string (e.g., 'ethereum:0x123', 'solana:sol')
             */
            locator: string;
            /**
             * The amount of the token after placing the decimal point
             */
            amount: string;
            /**
             * The raw amount of the token
             */
            rawAmount: string;
            /**
             * The mint hash of the token on Solana. Not present for native SOL.
             */
            mintHash?: string;
        } | {
            /**
             * Either a token string (e.g., 'eth', 'sol') or a token locator string (e.g., 'ethereum:0x123', 'solana:sol')
             */
            locator: string;
            /**
             * The amount of the token after placing the decimal point
             */
            amount: string;
            /**
             * The raw amount of the token
             */
            rawAmount: string;
            /**
             * The contract ID of the token on Stellar. Not present for native XLM.
             */
            contractId?: string;
        };
    };
}>;
/**
 * Array of NFTs in the wallet
 */
type WalletNftsResponseDto = Array<{
    /**
     * The blockchain chain
     */
    chain: 'solana' | 'sui' | 'aptos' | 'xion' | 'stellar' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    /**
     * NFT metadata including name, description, image, and attributes
     */
    metadata?: {
        name?: string;
        description?: string;
        image?: string;
        attributes?: Array<{
            trait_type: string;
            value: string | number | boolean;
        }>;
        animation_url?: string;
        external_url?: string;
    };
    /**
     * The unique locator for the token
     */
    locator: string;
    /**
     * Whether the token is marked as spam
     */
    isSpam?: boolean;
    /**
     * Subscription information if the token has subscription properties
     */
    subscription?: {
        expiresAt: string;
    };
}>;
/**
 * Wallet Activity Response (Unstable)
 * List of activities associated with a wallet including transactions and other events (unstable version)
 */
type WalletsActivityResponseUnstableDto = {
    events: Array<{
        /**
         * The symbol of the token involved in the activity
         */
        token_symbol?: string;
        /**
         * The hash of the token
         */
        mint_hash?: string;
        /**
         * The contract ID of the token
         */
        contractId?: string;
        /**
         * The hash of the transaction
         */
        transaction_hash: string;
        /**
         * The destination address of the transaction
         */
        to_address: string;
        /**
         * The source address of the transaction
         */
        from_address: string;
        /**
         * The timestamp when the activity occurred
         */
        timestamp: number;
        /**
         * The amount of the token involved in the activity
         */
        amount: string;
        /**
         * The type of activity (e.g., TRANSFER)
         */
        type: string;
    }>;
};
/**
 * List of signatures with their status, signing requirements, and wallet type specific data
 */
type WalletsMultipleSignatureV2025ResponseDto = {
    signatures: Array<{
        /**
         * Unique identifier for the signature
         */
        id: string;
        /**
         * The type of signature
         */
        type: 'message' | 'typed-data';
        /**
         * The blockchain type of the wallet
         */
        chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
        /**
         * The wallet type (smart or mpc)
         */
        walletType: 'smart' | 'mpc';
        /**
         * Current status of the signature
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Type-specific signature parameters
         */
        params: {
            /**
             * The message in plain text to sign
             */
            message: string;
            /**
             * The full signer object who will submit this signature. Defaults to the wallet's admin signer.
             */
            signer?: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The chain on which the signature will be submitted
             */
            chain?: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        } | {
            typedData: {
                domain: {
                    name: string;
                    version: string;
                    chainId: number;
                    /**
                     * An EVM address string
                     */
                    verifyingContract: string;
                    salt?: string;
                };
                types: {
                    [key: string]: Array<{
                        name: string;
                        type: string;
                    }>;
                };
                primaryType: string;
                message: {
                    [key: string]: unknown;
                };
            };
            /**
             * The chain on which the signature will be submitted
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
            /**
             * The full signer object who will approve this signature
             */
            signer?: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * Whether the signature corresponds to the smart wallet or to the signer. If true, the signature will be wrapped with ERC6492.
             */
            isSmartWalletSignature?: boolean;
        };
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the signature was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the signature fails
         */
        error?: unknown;
        /**
         * The wallet's output signature of the request
         */
        outputSignature?: string;
    }>;
};
/**
 * Transactions Response
 * List of transactions with their status, signing requirements, and wallet type specific data
 */
type WalletsMultipleTransactionV2025ResponseDto = {
    /**
     * Complete transaction response including status, signing requirements, and wallet type specific data
     */
    transactions: Array<{
        /**
         * The blockchain type of the wallet
         */
        chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
        /**
         * The wallet type (smart or mpc)
         */
        walletType: 'smart' | 'mpc';
        params: {
            /**
             * Transaction data to execute
             */
            calls: Array<{
                /**
                 * The recipient address for this transaction call
                 */
                address: string;
                /**
                 * The name of the function to call
                 */
                functionName: string;
                /**
                 * The ABI for the function to call
                 */
                abi: Array<{
                    type: 'error';
                    inputs: Array<unknown>;
                    name: string;
                } | {
                    type: 'event';
                    anonymous?: boolean;
                    inputs: Array<unknown & {
                        indexed?: boolean;
                    }>;
                    name: string;
                } | ({
                    constant?: boolean;
                    gas?: number;
                    payable?: boolean;
                } & ({
                    type: 'function';
                    inputs: Array<unknown>;
                    name: string;
                    outputs: Array<unknown>;
                    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
                } | {
                    type: 'constructor';
                    inputs: Array<unknown>;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'fallback';
                    inputs?: unknown;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'receive';
                    stateMutability: 'payable';
                }))>;
                /**
                 * The arguments to pass to the function
                 */
                args: Array<unknown>;
                /**
                 * The amount of native token to send in wei
                 */
                value?: string;
            } | {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The amount of native token to send in wei
                 */
                value: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            } | {
                /**
                 * Serialized EVM transaction
                 */
                transaction: unknown;
            }>;
            /**
             * The chain on which the transaction will be executed
             */
            chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
            /**
             * The full signer object who will submit this transaction
             */
            signer?: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
        };
        /**
         * EVM smart wallet transaction data
         * Transaction data specific to EVM smart wallets
         */
        onChain: {
            userOperation: {
                sender: string;
                nonce: string;
                callData: string;
                callGasLimit: string;
                verificationGasLimit: string;
                preVerificationGas: string;
                maxFeePerGas: string;
                maxPriorityFeePerGas: string;
                paymaster?: string;
                paymasterVerificationGasLimit?: string;
                paymasterData?: string;
                paymasterPostOpGasLimit?: string;
                signature: string;
                factory?: string;
                factoryData?: string;
            };
            userOperationHash: string;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The blockchain type of the wallet
         */
        chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
        /**
         * The wallet type (smart or mpc)
         */
        walletType: 'smart' | 'mpc';
        params: {
            /**
             * The transaction call to execute
             */
            call: {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            } | {
                /**
                 * The recipient address for this transaction call
                 */
                address: string;
                /**
                 * The name of the function to call
                 */
                functionName: string;
                /**
                 * The ABI for the function to call
                 */
                abi: Array<{
                    type: 'error';
                    inputs: Array<unknown>;
                    name: string;
                } | {
                    type: 'event';
                    anonymous?: boolean;
                    inputs: Array<unknown & {
                        indexed?: boolean;
                    }>;
                    name: string;
                } | ({
                    constant?: boolean;
                    gas?: number;
                    payable?: boolean;
                } & ({
                    type: 'function';
                    inputs: Array<unknown>;
                    name: string;
                    outputs: Array<unknown>;
                    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
                } | {
                    type: 'constructor';
                    inputs: Array<unknown>;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'fallback';
                    inputs?: unknown;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'receive';
                    stateMutability: 'payable';
                }))>;
                /**
                 * The arguments to pass to the function
                 */
                args: Array<unknown>;
            };
            /**
             * The chain on which the transaction will be executed
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        };
        /**
         * EVM MPC wallet transaction data
         * Transaction data specific to EVM MPC wallets
         */
        onChain: {
            call: {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            };
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The blockchain type of the wallet
         */
        chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
        /**
         * The wallet type (smart or mpc)
         */
        walletType: 'smart' | 'mpc';
        params: {
            /**
             * Base58 encoded serialized Solana transaction
             */
            transaction: string;
            /**
             * Full signer object
             */
            requiredSigners?: Array<{
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            }>;
            /**
             * The full signer object who will submit this transaction. Defaults to the admin signer.
             */
            signer?: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            feeConfig: {
                /**
                 * The address that will pay for the transaction
                 */
                feePayer: string;
                /**
                 * The token to use for the fee
                 */
                token: 'sol' | 'usdc' | 'usdt';
                /**
                 * The amount of the fee
                 */
                amount: string;
            } | {
                feePayer: 'crossmint';
                /**
                 * The amount of the fee
                 */
                amount: string;
            };
        };
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The blockchain type of the wallet
         */
        chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
        /**
         * The wallet type (smart or mpc)
         */
        walletType: 'smart' | 'mpc';
        params: {
            /**
             * Base58 encoded serialized Solana transaction
             */
            transaction: string;
            /**
             * Full signer object
             */
            requiredSigners?: Array<{
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            }>;
        };
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The blockchain type of the wallet
         */
        chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
        /**
         * The wallet type (smart or mpc)
         */
        walletType: 'smart' | 'mpc';
        params: {
            /**
             * Stellar transaction to execute
             */
            transaction: {
                /**
                 * The type of transaction to execute
                 */
                type: 'contract-call';
                /**
                 * The recipient address for this transaction call
                 */
                contractId: string;
                /**
                 * The name of the function to call
                 */
                method: string;
                /**
                 * The memo for the transaction
                 */
                memo?: {
                    /**
                     * The type of memo
                     */
                    type: 'text';
                    /**
                     * The value of the memo (max 28 bytes)
                     */
                    value: string;
                } | {
                    /**
                     * The type of memo
                     */
                    type: 'id';
                    /**
                     * The value of the memo (64-bit unsigned integer)
                     */
                    value: string;
                };
                /**
                 * The arguments to pass to the function
                 */
                args: {
                    [key: string]: unknown;
                };
            } | {
                /**
                 * The type of transaction to execute
                 */
                type: 'serialized-transaction';
                /**
                 * The XDR base64-encoded serialized transaction to execute
                 */
                serializedTransaction: string;
                /**
                 * The recipient address for this transaction call
                 */
                contractId: string;
            };
            /**
             * Signer Locator
             * The locator for the signer who will submit this transaction. Defaults to the admin signer.
             */
            signer?: string;
        };
        /**
         * Stellar on-chain data
         */
        onChain: {
            /**
             * Stellar on-chain transaction
             * The Stellar Transaction Envelope
             */
            transaction: {
                method: string;
                tx: string;
            };
            /**
             * The transaction hash
             */
            txId?: string;
            /**
             * The ledger number where the transaction was included
             */
            ledger?: number;
            /**
             * The expiration of the transaction
             */
            expiration: number;
            /**
             * The Transaction Result in XDR format
             */
            result?: unknown;
            /**
             * Optional link to view the transaction in an explorer
             */
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The full signer object that's pending approval
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number | string;
                /**
                 * The full signer object who submitted this signature
                 */
                signer: {
                    type: 'external-wallet';
                    /**
                     * The address of the external wallet
                     */
                    address: string;
                    /**
                     * The locator of the external wallet signer
                     */
                    locator: string;
                } | {
                    type: 'passkey';
                    /**
                     * The ID of the passkey
                     */
                    id: string;
                    /**
                     * The locator of the passkey signer
                     */
                    locator: string;
                } | {
                    type: 'api-key';
                    /**
                     * The address of the api key
                     */
                    address: string;
                    /**
                     * The locator of the api key signer
                     */
                    locator: string;
                } | {
                    type: 'email';
                    email: string;
                    locator: string;
                } | {
                    type: 'phone';
                    phone: string;
                    locator: string;
                };
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number | string;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number | string;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    }>;
};
/**
 * Complete signature response including status, signing requirements, and wallet type specific data
 */
type WalletsSignatureV2025ResponseDto = {
    /**
     * Unique identifier for the signature
     */
    id: string;
    /**
     * The type of signature
     */
    type: 'message' | 'typed-data';
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    walletType: 'smart' | 'mpc';
    /**
     * Current status of the signature
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Type-specific signature parameters
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
        /**
         * The full signer object who will submit this signature. Defaults to the wallet's admin signer.
         */
        signer?: {
            type: 'external-wallet';
            /**
             * The address of the external wallet
             */
            address: string;
            /**
             * The locator of the external wallet signer
             */
            locator: string;
        } | {
            type: 'passkey';
            /**
             * The ID of the passkey
             */
            id: string;
            /**
             * The locator of the passkey signer
             */
            locator: string;
        } | {
            type: 'api-key';
            /**
             * The address of the api key
             */
            address: string;
            /**
             * The locator of the api key signer
             */
            locator: string;
        } | {
            type: 'email';
            email: string;
            locator: string;
        } | {
            type: 'phone';
            phone: string;
            locator: string;
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain?: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    } | {
        typedData: {
            domain: {
                name: string;
                version: string;
                chainId: number;
                /**
                 * An EVM address string
                 */
                verifyingContract: string;
                salt?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {
                [key: string]: unknown;
            };
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        /**
         * The full signer object who will approve this signature
         */
        signer?: {
            type: 'external-wallet';
            /**
             * The address of the external wallet
             */
            address: string;
            /**
             * The locator of the external wallet signer
             */
            locator: string;
        } | {
            type: 'passkey';
            /**
             * The ID of the passkey
             */
            id: string;
            /**
             * The locator of the passkey signer
             */
            locator: string;
        } | {
            type: 'api-key';
            /**
             * The address of the api key
             */
            address: string;
            /**
             * The locator of the api key signer
             */
            locator: string;
        } | {
            type: 'email';
            email: string;
            locator: string;
        } | {
            type: 'phone';
            phone: string;
            locator: string;
        };
        /**
         * Whether the signature corresponds to the smart wallet or to the signer. If true, the signature will be wrapped with ERC6492.
         */
        isSmartWalletSignature?: boolean;
    };
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The full signer object that's pending approval
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number | string;
            /**
             * The full signer object who submitted this signature
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the signature was created
     */
    createdAt: number | string;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number | string;
    /**
     * Error message if the signature fails
     */
    error?: unknown;
    /**
     * The wallet's output signature of the request
     */
    outputSignature?: string;
};
/**
 * Complete transaction response including status, signing requirements, and wallet type specific data
 */
type WalletsTransactionV2025ResponseDto = {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    walletType: 'smart' | 'mpc';
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * Serialized EVM transaction
             */
            transaction: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
        /**
         * The full signer object who will submit this transaction
         */
        signer?: {
            type: 'external-wallet';
            /**
             * The address of the external wallet
             */
            address: string;
            /**
             * The locator of the external wallet signer
             */
            locator: string;
        } | {
            type: 'passkey';
            /**
             * The ID of the passkey
             */
            id: string;
            /**
             * The locator of the passkey signer
             */
            locator: string;
        } | {
            type: 'api-key';
            /**
             * The address of the api key
             */
            address: string;
            /**
             * The locator of the api key signer
             */
            locator: string;
        } | {
            type: 'email';
            email: string;
            locator: string;
        } | {
            type: 'phone';
            phone: string;
            locator: string;
        };
    };
    /**
     * EVM smart wallet transaction data
     * Transaction data specific to EVM smart wallets
     */
    onChain: {
        userOperation: {
            sender: string;
            nonce: string;
            callData: string;
            callGasLimit: string;
            verificationGasLimit: string;
            preVerificationGas: string;
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
            paymaster?: string;
            paymasterVerificationGasLimit?: string;
            paymasterData?: string;
            paymasterPostOpGasLimit?: string;
            signature: string;
            factory?: string;
            factoryData?: string;
        };
        userOperationHash: string;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The full signer object that's pending approval
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number | string;
            /**
             * The full signer object who submitted this signature
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number | string;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number | string;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    walletType: 'smart' | 'mpc';
    params: {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
    /**
     * EVM MPC wallet transaction data
     * Transaction data specific to EVM MPC wallets
     */
    onChain: {
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        };
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The full signer object that's pending approval
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number | string;
            /**
             * The full signer object who submitted this signature
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number | string;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number | string;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    walletType: 'smart' | 'mpc';
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Full signer object
         */
        requiredSigners?: Array<{
            type: 'external-wallet';
            /**
             * The address of the external wallet
             */
            address: string;
            /**
             * The locator of the external wallet signer
             */
            locator: string;
        } | {
            type: 'passkey';
            /**
             * The ID of the passkey
             */
            id: string;
            /**
             * The locator of the passkey signer
             */
            locator: string;
        } | {
            type: 'api-key';
            /**
             * The address of the api key
             */
            address: string;
            /**
             * The locator of the api key signer
             */
            locator: string;
        } | {
            type: 'email';
            email: string;
            locator: string;
        } | {
            type: 'phone';
            phone: string;
            locator: string;
        }>;
        /**
         * The full signer object who will submit this transaction. Defaults to the admin signer.
         */
        signer?: {
            type: 'external-wallet';
            /**
             * The address of the external wallet
             */
            address: string;
            /**
             * The locator of the external wallet signer
             */
            locator: string;
        } | {
            type: 'passkey';
            /**
             * The ID of the passkey
             */
            id: string;
            /**
             * The locator of the passkey signer
             */
            locator: string;
        } | {
            type: 'api-key';
            /**
             * The address of the api key
             */
            address: string;
            /**
             * The locator of the api key signer
             */
            locator: string;
        } | {
            type: 'email';
            email: string;
            locator: string;
        } | {
            type: 'phone';
            phone: string;
            locator: string;
        };
        feeConfig: {
            /**
             * The address that will pay for the transaction
             */
            feePayer: string;
            /**
             * The token to use for the fee
             */
            token: 'sol' | 'usdc' | 'usdt';
            /**
             * The amount of the fee
             */
            amount: string;
        } | {
            feePayer: 'crossmint';
            /**
             * The amount of the fee
             */
            amount: string;
        };
    };
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The full signer object that's pending approval
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number | string;
            /**
             * The full signer object who submitted this signature
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number | string;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number | string;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    walletType: 'smart' | 'mpc';
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Full signer object
         */
        requiredSigners?: Array<{
            type: 'external-wallet';
            /**
             * The address of the external wallet
             */
            address: string;
            /**
             * The locator of the external wallet signer
             */
            locator: string;
        } | {
            type: 'passkey';
            /**
             * The ID of the passkey
             */
            id: string;
            /**
             * The locator of the passkey signer
             */
            locator: string;
        } | {
            type: 'api-key';
            /**
             * The address of the api key
             */
            address: string;
            /**
             * The locator of the api key signer
             */
            locator: string;
        } | {
            type: 'email';
            email: string;
            locator: string;
        } | {
            type: 'phone';
            phone: string;
            locator: string;
        }>;
    };
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The full signer object that's pending approval
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number | string;
            /**
             * The full signer object who submitted this signature
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number | string;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number | string;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm' | 'solana' | 'aptos' | 'sui' | 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    walletType: 'smart' | 'mpc';
    params: {
        /**
         * Stellar transaction to execute
         */
        transaction: {
            /**
             * The type of transaction to execute
             */
            type: 'contract-call';
            /**
             * The recipient address for this transaction call
             */
            contractId: string;
            /**
             * The name of the function to call
             */
            method: string;
            /**
             * The memo for the transaction
             */
            memo?: {
                /**
                 * The type of memo
                 */
                type: 'text';
                /**
                 * The value of the memo (max 28 bytes)
                 */
                value: string;
            } | {
                /**
                 * The type of memo
                 */
                type: 'id';
                /**
                 * The value of the memo (64-bit unsigned integer)
                 */
                value: string;
            };
            /**
             * The arguments to pass to the function
             */
            args: {
                [key: string]: unknown;
            };
        } | {
            /**
             * The type of transaction to execute
             */
            type: 'serialized-transaction';
            /**
             * The XDR base64-encoded serialized transaction to execute
             */
            serializedTransaction: string;
            /**
             * The recipient address for this transaction call
             */
            contractId: string;
        };
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
    };
    /**
     * Stellar on-chain data
     */
    onChain: {
        /**
         * Stellar on-chain transaction
         * The Stellar Transaction Envelope
         */
        transaction: {
            method: string;
            tx: string;
        };
        /**
         * The transaction hash
         */
        txId?: string;
        /**
         * The ledger number where the transaction was included
         */
        ledger?: number;
        /**
         * The expiration of the transaction
         */
        expiration: number;
        /**
         * The Transaction Result in XDR format
         */
        result?: unknown;
        /**
         * Optional link to view the transaction in an explorer
         */
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The full signer object that's pending approval
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number | string;
            /**
             * The full signer object who submitted this signature
             */
            signer: {
                type: 'external-wallet';
                /**
                 * The address of the external wallet
                 */
                address: string;
                /**
                 * The locator of the external wallet signer
                 */
                locator: string;
            } | {
                type: 'passkey';
                /**
                 * The ID of the passkey
                 */
                id: string;
                /**
                 * The locator of the passkey signer
                 */
                locator: string;
            } | {
                type: 'api-key';
                /**
                 * The address of the api key
                 */
                address: string;
                /**
                 * The locator of the api key signer
                 */
                locator: string;
            } | {
                type: 'email';
                email: string;
                locator: string;
            } | {
                type: 'phone';
                phone: string;
                locator: string;
            };
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number | string;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number | string;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
};
/**
 * Wallet Activity Response
 * List of activities associated with a wallet including transactions and other events
 */
type WalletsV1Alpha2ActivityResponseDto = {
    events: Array<{
        /**
         * The symbol of the token involved in the activity
         */
        token_symbol?: string;
        /**
         * The hash of the token
         */
        mint_hash?: string;
        /**
         * The hash of the transaction
         */
        transaction_hash: string;
        /**
         * The destination address of the transaction
         */
        to_address: string;
        /**
         * The source address of the transaction
         */
        from_address: string;
        /**
         * The timestamp when the activity occurred
         */
        timestamp: number;
        /**
         * The amount of the token involved in the activity
         */
        amount: string;
        /**
         * The type of activity (e.g., TRANSFER)
         */
        type: string;
    }>;
};
/**
 * List of signatures with their status, signing requirements, and wallet type specific data
 */
type WalletsV1Alpha2MultipleSignatureResponseDto = {
    signatures: Array<{
        /**
         * Unique identifier for the signature
         */
        id: string;
        /**
         * The type of signature
         */
        type: 'evm-message' | 'solana-message' | 'evm-typed-data' | 'aptos-message' | 'sui-message';
        /**
         * Current status of the signature
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Type-specific signature parameters
         */
        params: {
            /**
             * The message in plain text to sign
             */
            message: string;
            /**
             * Signer Locator
             * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
             */
            signer?: string;
            /**
             * The chain on which the signature will be submitted
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        } | {
            /**
             * The message in plain text to sign
             */
            message: string;
        } | {
            typedData: {
                domain: {
                    name: string;
                    version: string;
                    chainId: number;
                    /**
                     * An EVM address string
                     */
                    verifyingContract: string;
                    salt?: string;
                };
                types: {
                    [key: string]: Array<{
                        name: string;
                        type: string;
                    }>;
                };
                primaryType: string;
                message: {
                    [key: string]: unknown;
                };
            };
            /**
             * The chain on which the signature will be submitted
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
            /**
             * Signer Locator
             * The locator for the signer who will approve this signature
             */
            signer?: string;
            /**
             * Whether the signature corresponds to the smart wallet or to the signer. Defaults to true (smart wallet signature wrapped with ERC6492). Set to false for signer signature.
             */
            isSmartWalletSignature?: boolean;
        };
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * Signer Locator
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the signature was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the signature fails
         */
        error?: unknown;
        /**
         * The wallet's output signature of the request
         */
        outputSignature?: string;
    }>;
};
/**
 * Complete signature response including status, signing requirements, and wallet type specific data
 */
type WalletsV1Alpha2SignatureResponseDto = {
    /**
     * Unique identifier for the signature
     */
    id: string;
    /**
     * The type of signature
     */
    type: 'evm-message' | 'solana-message' | 'evm-typed-data' | 'aptos-message' | 'sui-message';
    /**
     * Current status of the signature
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Type-specific signature parameters
     */
    params: {
        /**
         * The message in plain text to sign
         */
        message: string;
        /**
         * Signer Locator
         * The locator for the signer who will submit this signature. Defaults to the wallet's admin signer.
         */
        signer?: string;
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    } | {
        /**
         * The message in plain text to sign
         */
        message: string;
    } | {
        typedData: {
            domain: {
                name: string;
                version: string;
                chainId: number;
                /**
                 * An EVM address string
                 */
                verifyingContract: string;
                salt?: string;
            };
            types: {
                [key: string]: Array<{
                    name: string;
                    type: string;
                }>;
            };
            primaryType: string;
            message: {
                [key: string]: unknown;
            };
        };
        /**
         * The chain on which the signature will be submitted
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        /**
         * Signer Locator
         * The locator for the signer who will approve this signature
         */
        signer?: string;
        /**
         * Whether the signature corresponds to the smart wallet or to the signer. Defaults to true (smart wallet signature wrapped with ERC6492). Set to false for signer signature.
         */
        isSmartWalletSignature?: boolean;
    };
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the signature was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the signature fails
     */
    error?: unknown;
    /**
     * The wallet's output signature of the request
     */
    outputSignature?: string;
};
/**
 * Complete transaction response including status, signing requirements, and wallet type specific data
 */
type WalletsV1Alpha2TransactionResponseDto = {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'evm-smart-wallet';
    /**
     * EVM smart wallet transaction parameters
     */
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * Serialized EVM transaction
             */
            transaction: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction
         */
        signer?: string;
    };
    /**
     * EVM smart wallet transaction data
     * EVM smart wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        userOperation: {
            sender: string;
            nonce: string;
            callData: string;
            callGasLimit: string;
            verificationGasLimit: string;
            preVerificationGas: string;
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
            paymaster?: string;
            paymasterVerificationGasLimit?: string;
            paymasterData?: string;
            paymasterPostOpGasLimit?: string;
            signature: string;
            factory?: string;
            factoryData?: string;
        };
        userOperationHash: string;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'solana-mpc-wallet';
    /**
     * Solana custodial wallet transaction parameters
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
    };
    /**
     * Solana custodial wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'evm-mpc-wallet';
    /**
     * EVM MPC wallet transaction parameters
     */
    params: {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
    /**
     * EVM MPC wallet transaction data
     * EVM MPC wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        };
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'solana-smart-wallet';
    /**
     * Solana smart wallet transaction parameters
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
        feeConfig: {
            /**
             * The address that will pay for the transaction
             */
            feePayer: string;
            /**
             * The token to use for the fee
             */
            token: 'sol' | 'usdc' | 'usdt';
            /**
             * The amount of the fee
             */
            amount: string;
        } | {
            feePayer: 'crossmint';
            /**
             * The amount of the fee
             */
            amount: string;
        };
    };
    /**
     * Solana smart wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
};
/**
 * Complete transaction response including status, signing requirements, and wallet type specific data
 */
type WalletsV1Alpha2TransactionResponseWithSendParamsDto = {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'evm-smart-wallet';
    /**
     * EVM smart wallet transaction parameters
     */
    params: {
        /**
         * Transaction data to execute
         */
        calls: Array<{
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
            /**
             * The amount of native token to send in wei
             */
            value?: string;
        } | {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The amount of native token to send in wei
             */
            value: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * Serialized EVM transaction
             */
            transaction: unknown;
        }>;
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction
         */
        signer?: string;
    };
    /**
     * EVM smart wallet transaction data
     * EVM smart wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        userOperation: {
            sender: string;
            nonce: string;
            callData: string;
            callGasLimit: string;
            verificationGasLimit: string;
            preVerificationGas: string;
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
            paymaster?: string;
            paymasterVerificationGasLimit?: string;
            paymasterData?: string;
            paymasterPostOpGasLimit?: string;
            signature: string;
            factory?: string;
            factoryData?: string;
        };
        userOperationHash: string;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'solana-mpc-wallet';
    /**
     * Solana custodial wallet transaction parameters
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
    };
    /**
     * Solana custodial wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'evm-mpc-wallet';
    /**
     * EVM MPC wallet transaction parameters
     */
    params: {
        /**
         * The transaction call to execute
         */
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        } | {
            /**
             * The recipient address for this transaction call
             */
            address: string;
            /**
             * The name of the function to call
             */
            functionName: string;
            /**
             * The ABI for the function to call
             */
            abi: Array<{
                type: 'error';
                inputs: Array<unknown>;
                name: string;
            } | {
                type: 'event';
                anonymous?: boolean;
                inputs: Array<unknown & {
                    indexed?: boolean;
                }>;
                name: string;
            } | ({
                constant?: boolean;
                gas?: number;
                payable?: boolean;
            } & ({
                type: 'function';
                inputs: Array<unknown>;
                name: string;
                outputs: Array<unknown>;
                stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
            } | {
                type: 'constructor';
                inputs: Array<unknown>;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'fallback';
                inputs?: unknown;
                stateMutability: 'payable' | 'nonpayable';
            } | {
                type: 'receive';
                stateMutability: 'payable';
            }))>;
            /**
             * The arguments to pass to the function
             */
            args: Array<unknown>;
        };
        /**
         * The chain on which the transaction will be executed
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
    };
    /**
     * EVM MPC wallet transaction data
     * EVM MPC wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        call: {
            /**
             * The recipient address for this transaction call
             */
            to: string;
            /**
             * The encoded calldata for this transaction
             */
            data: unknown;
        };
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
} | {
    /**
     * The type of wallet that created this transaction
     */
    walletType: 'solana-smart-wallet';
    /**
     * Solana smart wallet transaction parameters
     */
    params: {
        /**
         * Base58 encoded serialized Solana transaction
         */
        transaction: string;
        /**
         * Optional array of additional signers required for the transaction
         */
        requiredSigners?: Array<string>;
        /**
         * Signer Locator
         * The locator for the signer who will submit this transaction. Defaults to the admin signer.
         */
        signer?: string;
        feeConfig: {
            /**
             * The address that will pay for the transaction
             */
            feePayer: string;
            /**
             * The token to use for the fee
             */
            token: 'sol' | 'usdc' | 'usdt';
            /**
             * The amount of the fee
             */
            amount: string;
        } | {
            feePayer: 'crossmint';
            /**
             * The amount of the fee
             */
            amount: string;
        };
    };
    /**
     * Solana smart wallet transaction data including input parameters and chain specific details
     */
    onChain: {
        transaction: string;
        lastValidBlockHeight?: number;
        txId?: string;
        explorerLink?: string;
    };
    /**
     * Unique identifier for the transaction
     */
    id: string;
    /**
     * Current status of the transaction
     */
    status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
    /**
     * Complete approval data including requirements, pending and submitted signatures
     */
    approvals?: {
        /**
         * List of pending signatures
         */
        pending: Array<{
            /**
             * The locator of the signer that's pending approval
             */
            signer: string;
            /**
             * The message that needs to be signed
             */
            message: string;
        }>;
        /**
         * Record of all submitted signatures
         */
        submitted: Array<{
            /**
             * The cryptographic signature
             */
            signature: string;
            /**
             * When the signature was submitted
             */
            submittedAt: number;
            /**
             * Signer Locator
             * The locator of the signer who submitted this signature
             */
            signer: string;
            /**
             * The message that was signed
             */
            message: string;
            /**
             * Additional metadata about the signature submission
             */
            metadata?: {
                deviceInfo?: string;
                ipAddress?: string;
                userAgent?: string;
            };
        }>;
        /**
         * Number of required approvals for the transaction
         */
        required?: number;
    };
    /**
     * ISO timestamp when the transaction was created
     */
    createdAt: number;
    /**
     * ISO timestamp when the transaction reached finality
     */
    completedAt?: number;
    /**
     * Error message if the transaction fails after submission
     */
    error?: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    sendParams?: {
        /**
         * The token locator that's being sent
         */
        token: string;
        /**
         * The parameters for the send token transaction
         */
        params: {
            /**
             * The amount of the token to send
             */
            amount?: string;
            /**
             * The recipient locator for the token
             */
            recipient: string;
            /**
             * The recipient address for the token
             */
            recipientAddress: string;
        };
    };
};
/**
 * Transactions Response
 * List of transactions with their status, signing requirements, and wallet type specific data
 */
type WalletsV1Alpha2TransactionsResponseDto = {
    /**
     * Complete transaction response including status, signing requirements, and wallet type specific data
     */
    transactions: Array<{
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'evm-smart-wallet';
        /**
         * EVM smart wallet transaction parameters
         */
        params: {
            /**
             * Transaction data to execute
             */
            calls: Array<{
                /**
                 * The recipient address for this transaction call
                 */
                address: string;
                /**
                 * The name of the function to call
                 */
                functionName: string;
                /**
                 * The ABI for the function to call
                 */
                abi: Array<{
                    type: 'error';
                    inputs: Array<unknown>;
                    name: string;
                } | {
                    type: 'event';
                    anonymous?: boolean;
                    inputs: Array<unknown & {
                        indexed?: boolean;
                    }>;
                    name: string;
                } | ({
                    constant?: boolean;
                    gas?: number;
                    payable?: boolean;
                } & ({
                    type: 'function';
                    inputs: Array<unknown>;
                    name: string;
                    outputs: Array<unknown>;
                    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
                } | {
                    type: 'constructor';
                    inputs: Array<unknown>;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'fallback';
                    inputs?: unknown;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'receive';
                    stateMutability: 'payable';
                }))>;
                /**
                 * The arguments to pass to the function
                 */
                args: Array<unknown>;
                /**
                 * The amount of native token to send in wei
                 */
                value?: string;
            } | {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The amount of native token to send in wei
                 */
                value: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            } | {
                /**
                 * Serialized EVM transaction
                 */
                transaction: unknown;
            }>;
            /**
             * The chain on which the transaction will be executed
             */
            chain: 'abstract' | 'apechain' | 'arbitrum' | 'arbitrumnova' | 'avalanche' | 'base' | 'bsc' | 'flow' | 'mantle' | 'mode' | 'optimism' | 'polygon' | 'scroll' | 'sei-pacific-1' | 'shape' | 'story' | 'world-chain' | 'zora' | 'abstract-testnet' | 'arbitrum-sepolia' | 'avalanche-fuji' | 'base-sepolia' | 'curtis' | 'ethereum-sepolia' | 'flow-testnet' | 'mantle-sepolia' | 'mode-sepolia' | 'optimism-sepolia' | 'polygon-amoy' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'story-testnet' | 'world-chain-sepolia' | 'zora-sepolia';
            /**
             * Signer Locator
             * The locator for the signer who will submit this transaction
             */
            signer?: string;
        };
        /**
         * EVM smart wallet transaction data
         * EVM smart wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            userOperation: {
                sender: string;
                nonce: string;
                callData: string;
                callGasLimit: string;
                verificationGasLimit: string;
                preVerificationGas: string;
                maxFeePerGas: string;
                maxPriorityFeePerGas: string;
                paymaster?: string;
                paymasterVerificationGasLimit?: string;
                paymasterData?: string;
                paymasterPostOpGasLimit?: string;
                signature: string;
                factory?: string;
                factoryData?: string;
            };
            userOperationHash: string;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * Signer Locator
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'solana-mpc-wallet';
        /**
         * Solana custodial wallet transaction parameters
         */
        params: {
            /**
             * Base58 encoded serialized Solana transaction
             */
            transaction: string;
            /**
             * Optional array of additional signers required for the transaction
             */
            requiredSigners?: Array<string>;
        };
        /**
         * Solana custodial wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * Signer Locator
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'evm-mpc-wallet';
        /**
         * EVM MPC wallet transaction parameters
         */
        params: {
            /**
             * The transaction call to execute
             */
            call: {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            } | {
                /**
                 * The recipient address for this transaction call
                 */
                address: string;
                /**
                 * The name of the function to call
                 */
                functionName: string;
                /**
                 * The ABI for the function to call
                 */
                abi: Array<{
                    type: 'error';
                    inputs: Array<unknown>;
                    name: string;
                } | {
                    type: 'event';
                    anonymous?: boolean;
                    inputs: Array<unknown & {
                        indexed?: boolean;
                    }>;
                    name: string;
                } | ({
                    constant?: boolean;
                    gas?: number;
                    payable?: boolean;
                } & ({
                    type: 'function';
                    inputs: Array<unknown>;
                    name: string;
                    outputs: Array<unknown>;
                    stateMutability: 'pure' | 'view' | 'nonpayable' | 'payable';
                } | {
                    type: 'constructor';
                    inputs: Array<unknown>;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'fallback';
                    inputs?: unknown;
                    stateMutability: 'payable' | 'nonpayable';
                } | {
                    type: 'receive';
                    stateMutability: 'payable';
                }))>;
                /**
                 * The arguments to pass to the function
                 */
                args: Array<unknown>;
            };
            /**
             * The chain on which the transaction will be executed
             */
            chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow';
        };
        /**
         * EVM MPC wallet transaction data
         * EVM MPC wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            call: {
                /**
                 * The recipient address for this transaction call
                 */
                to: string;
                /**
                 * The encoded calldata for this transaction
                 */
                data: unknown;
            };
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * Signer Locator
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    } | {
        /**
         * The type of wallet that created this transaction
         */
        walletType: 'solana-smart-wallet';
        /**
         * Solana smart wallet transaction parameters
         */
        params: {
            /**
             * Base58 encoded serialized Solana transaction
             */
            transaction: string;
            /**
             * Optional array of additional signers required for the transaction
             */
            requiredSigners?: Array<string>;
            /**
             * Signer Locator
             * The locator for the signer who will submit this transaction. Defaults to the admin signer.
             */
            signer?: string;
            feeConfig: {
                /**
                 * The address that will pay for the transaction
                 */
                feePayer: string;
                /**
                 * The token to use for the fee
                 */
                token: 'sol' | 'usdc' | 'usdt';
                /**
                 * The amount of the fee
                 */
                amount: string;
            } | {
                feePayer: 'crossmint';
                /**
                 * The amount of the fee
                 */
                amount: string;
            };
        };
        /**
         * Solana smart wallet transaction data including input parameters and chain specific details
         */
        onChain: {
            transaction: string;
            lastValidBlockHeight?: number;
            txId?: string;
            explorerLink?: string;
        };
        /**
         * Unique identifier for the transaction
         */
        id: string;
        /**
         * Current status of the transaction
         */
        status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
        /**
         * Complete approval data including requirements, pending and submitted signatures
         */
        approvals?: {
            /**
             * List of pending signatures
             */
            pending: Array<{
                /**
                 * The locator of the signer that's pending approval
                 */
                signer: string;
                /**
                 * The message that needs to be signed
                 */
                message: string;
            }>;
            /**
             * Record of all submitted signatures
             */
            submitted: Array<{
                /**
                 * The cryptographic signature
                 */
                signature: string;
                /**
                 * When the signature was submitted
                 */
                submittedAt: number;
                /**
                 * Signer Locator
                 * The locator of the signer who submitted this signature
                 */
                signer: string;
                /**
                 * The message that was signed
                 */
                message: string;
                /**
                 * Additional metadata about the signature submission
                 */
                metadata?: {
                    deviceInfo?: string;
                    ipAddress?: string;
                    userAgent?: string;
                };
            }>;
            /**
             * Number of required approvals for the transaction
             */
            required?: number;
        };
        /**
         * ISO timestamp when the transaction was created
         */
        createdAt: number;
        /**
         * ISO timestamp when the transaction reached finality
         */
        completedAt?: number;
        /**
         * Error message if the transaction fails after submission
         */
        error?: {
            reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
            message: string;
        } | {
            reason: 'program_error';
            message: string;
            logs?: unknown;
        } | {
            reason: 'execution_reverted';
            message: string;
            revert?: {
                type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                reason: string;
                reasonData?: string | {
                    [key: string]: unknown;
                };
                explorerLink?: string;
                simulationLink?: string;
            };
        };
        sendParams?: {
            /**
             * The token locator that's being sent
             */
            token: string;
            /**
             * The parameters for the send token transaction
             */
            params: {
                /**
                 * The amount of the token to send
                 */
                amount?: string;
                /**
                 * The recipient locator for the token
                 */
                recipient: string;
                /**
                 * The recipient address for the token
                 */
                recipientAddress: string;
            };
        };
    }>;
};
/**
 * Wallet error
 */
type WalletV1Alpha2ErrorDto = {
    error: true;
    /**
     * Error message
     */
    message: string;
};
/**
 * Complete wallet configuration including type-specific settings
 */
type WalletV1Alpha2ResponseDto = {
    /**
     * The type of wallet configuration
     */
    type: 'evm-smart-wallet';
    /**
     * EVM smart wallet type specific configuration settings
     */
    config: {
        adminSigner: {
            /**
             * Identifier for EVM keypair signer type
             */
            type: 'evm-keypair';
            /**
             * The Ethereum address of the external signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for EVM Fireblocks custodial signer type
             */
            type: 'evm-fireblocks-custodial';
            /**
             * The Ethereum address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'evm-passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a string representation of a bigint
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a string representation of a bigint
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        };
        /**
         * Optional array of additional signers for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Identifier for EVM keypair signer type
             */
            type: 'evm-keypair';
            /**
             * The Ethereum address of the external signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for EVM Fireblocks custodial signer type
             */
            type: 'evm-fireblocks-custodial';
            /**
             * The Ethereum address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'evm-passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a string representation of a bigint
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a string representation of a bigint
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Specifies the type of EVM signer being used, describing the method of key management and transaction signing. `evm-keypair` indicates a signer using a locally managed keypair, suitable for non-custodial wallets. `evm-fireblocks-custodial` refers to a signer managed by Fireblocks, a custodial service provider.
             */
            type: 'evm-keypair' | 'evm-fireblocks-custodial' | 'evm-passkey';
            /**
             * Signer Locator
             * The locator of the signer
             */
            locator: string;
            /**
             * The expiry date of the signer in ISO 8601 format
             */
            expiresAt?: number;
            /**
             * The permissions of the signer following ERC-7715
             */
            permissions?: Array<{
                type: 'native-token-transfer';
                data: {
                    allowance: string;
                };
            } | {
                type: 'erc20-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    allowance: string;
                };
            } | {
                type: 'erc721-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    /**
                     * The token IDs that can be transferred
                     */
                    tokenIds: Array<string>;
                };
            } | {
                type: 'erc1155-token-transfer';
                data: {
                    /**
                     * The address of the smart contract that can be interacted with
                     */
                    address: string;
                    /**
                     * The token IDs and allowances that can be transferred
                     */
                    allowances: {
                        [key: string]: string;
                    };
                };
            } | {
                type: 'gas-limit';
                data: {
                    limit: string;
                    enforcePaymaster?: boolean;
                    allowedPaymaster?: string;
                };
            } | {
                type: 'call-limit';
                data: {
                    count: number;
                };
            } | {
                type: 'rate-limit';
                data: {
                    count: number;
                    /**
                     * Time window in seconds
                     */
                    interval: number;
                };
            }>;
        }>;
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'solana-smart-wallet';
    /**
     * Solana Smart wallet type specific configuration settings
     */
    config: {
        adminSigner: {
            /**
             * Type identifier for Solana keypair signers
             */
            type: 'solana-keypair';
            /**
             * The Solana address of the signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Type identifier for Solana custodial signers
             */
            type: 'solana-fireblocks-custodial';
            /**
             * The Solana address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        };
        /**
         * Optional array of additional signers for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Specifies the type of Solana signer being used, describing the method of key management and transaction signing.
             */
            type: 'solana-keypair' | 'solana-fireblocks-custodial';
            /**
             * The address of the signer
             */
            address: string;
            /**
             * Signer Locator
             * The locator of the signer
             */
            locator: string;
            /**
             * The transaction for the signer
             */
            transaction: {
                /**
                 * Solana smart wallet transaction data including input parameters and chain specific details
                 */
                onChain: {
                    transaction: string;
                    lastValidBlockHeight?: number;
                    txId?: string;
                    explorerLink?: string;
                };
                /**
                 * Unique identifier for the transaction
                 */
                id: string;
                /**
                 * Current status of the transaction
                 */
                status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
                /**
                 * Complete approval data including requirements, pending and submitted signatures
                 */
                approvals?: {
                    /**
                     * List of pending signatures
                     */
                    pending: Array<{
                        /**
                         * The locator of the signer that's pending approval
                         */
                        signer: string;
                        /**
                         * The message that needs to be signed
                         */
                        message: string;
                    }>;
                    /**
                     * Record of all submitted signatures
                     */
                    submitted: Array<{
                        /**
                         * The cryptographic signature
                         */
                        signature: string;
                        /**
                         * When the signature was submitted
                         */
                        submittedAt: number;
                        /**
                         * Signer Locator
                         * The locator of the signer who submitted this signature
                         */
                        signer: string;
                        /**
                         * The message that was signed
                         */
                        message: string;
                        /**
                         * Additional metadata about the signature submission
                         */
                        metadata?: {
                            deviceInfo?: string;
                            ipAddress?: string;
                            userAgent?: string;
                        };
                    }>;
                    /**
                     * Number of required approvals for the transaction
                     */
                    required?: number;
                };
                /**
                 * ISO timestamp when the transaction was created
                 */
                createdAt: number;
                /**
                 * ISO timestamp when the transaction reached finality
                 */
                completedAt?: number;
                /**
                 * Error message if the transaction fails after submission
                 */
                error?: {
                    reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
                    message: string;
                } | {
                    reason: 'program_error';
                    message: string;
                    logs?: unknown;
                } | {
                    reason: 'execution_reverted';
                    message: string;
                    revert?: {
                        type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                        reason: string;
                        reasonData?: string | {
                            [key: string]: unknown;
                        };
                        explorerLink?: string;
                        simulationLink?: string;
                    };
                };
                sendParams?: {
                    /**
                     * The token locator that's being sent
                     */
                    token: string;
                    /**
                     * The parameters for the send token transaction
                     */
                    params: {
                        /**
                         * The amount of the token to send
                         */
                        amount?: string;
                        /**
                         * The recipient locator for the token
                         */
                        recipient: string;
                        /**
                         * The recipient address for the token
                         */
                        recipientAddress: string;
                    };
                };
            };
        }>;
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'solana-mpc-wallet';
    /**
     * Solana MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'aptos-mpc-wallet';
    /**
     * Aptos MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'sui-mpc-wallet';
    /**
     * Sui MPC wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
} | {
    /**
     * The type of wallet configuration
     */
    type: 'evm-mpc-wallet';
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that is linked to this wallet in format <locatorType>:<value>
     */
    linkedUser?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number;
};
/**
 * Wallet transaction error
 */
type WalletV1Alpha2TransactionErrorDto = {
    /**
     * Error
     */
    error: {
        reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
        message: string;
    } | {
        reason: 'program_error';
        message: string;
        logs?: unknown;
    } | {
        reason: 'execution_reverted';
        message: string;
        revert?: {
            type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
            reason: string;
            reasonData?: string | {
                [key: string]: unknown;
            };
            explorerLink?: string;
            simulationLink?: string;
        };
    };
    /**
     * Error message
     */
    message: string;
};
/**
 * Complete wallet configuration including type-specific settings
 */
type WalletV2025ResponseDto = {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'evm';
    /**
     * The wallet type (smart or mpc)
     */
    type: 'smart' | 'mpc';
    /**
     * EVM wallet type specific configuration settings
     */
    config?: {
        adminSigner: {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
            /**
             * The blockchain address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        };
        /**
         * Optional array of additional signers for the wallet
         */
        delegatedSigners?: Array<{
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
            /**
             * The blockchain address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for the Passkey signer type
             */
            type: 'passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        }>;
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that owns this wallet in format <locatorType>:<value>
     */
    owner?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number | string;
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'solana';
    /**
     * The wallet type (smart or mpc)
     */
    type: 'smart' | 'mpc';
    /**
     * Solana wallet type specific configuration settings
     */
    config?: {
        adminSigner: {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
            /**
             * The blockchain address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        };
        /**
         * Delegated Signer Response
         * Complete delegated signer response including the signer and authorization transaction
         */
        delegatedSigners?: Array<({
            /**
             * Identifier for the Passkey signer type
             */
            type: 'passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
            /**
             * The blockchain address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        }) & {
            /**
             * The transaction for the signer
             */
            transaction?: {
                chainType: 'solana';
                onChain: {
                    transaction: string;
                    lastValidBlockHeight?: number;
                    txId?: string;
                    explorerLink?: string;
                };
                /**
                 * Unique identifier for the transaction
                 */
                id: string;
                /**
                 * Current status of the transaction
                 */
                status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
                /**
                 * Complete approval data including requirements, pending and submitted signatures
                 */
                approvals?: {
                    /**
                     * List of pending signatures
                     */
                    pending: Array<{
                        /**
                         * The full signer object that's pending approval
                         */
                        signer: {
                            type: 'external-wallet';
                            /**
                             * The address of the external wallet
                             */
                            address: string;
                            /**
                             * The locator of the external wallet signer
                             */
                            locator: string;
                        } | {
                            type: 'passkey';
                            /**
                             * The ID of the passkey
                             */
                            id: string;
                            /**
                             * The locator of the passkey signer
                             */
                            locator: string;
                        } | {
                            type: 'api-key';
                            /**
                             * The address of the api key
                             */
                            address: string;
                            /**
                             * The locator of the api key signer
                             */
                            locator: string;
                        } | {
                            type: 'email';
                            email: string;
                            locator: string;
                        } | {
                            type: 'phone';
                            phone: string;
                            locator: string;
                        };
                        /**
                         * The message that needs to be signed
                         */
                        message: string;
                    }>;
                    /**
                     * Record of all submitted signatures
                     */
                    submitted: Array<{
                        /**
                         * The cryptographic signature
                         */
                        signature: string;
                        /**
                         * When the signature was submitted
                         */
                        submittedAt: number | string;
                        /**
                         * The full signer object who submitted this signature
                         */
                        signer: {
                            type: 'external-wallet';
                            /**
                             * The address of the external wallet
                             */
                            address: string;
                            /**
                             * The locator of the external wallet signer
                             */
                            locator: string;
                        } | {
                            type: 'passkey';
                            /**
                             * The ID of the passkey
                             */
                            id: string;
                            /**
                             * The locator of the passkey signer
                             */
                            locator: string;
                        } | {
                            type: 'api-key';
                            /**
                             * The address of the api key
                             */
                            address: string;
                            /**
                             * The locator of the api key signer
                             */
                            locator: string;
                        } | {
                            type: 'email';
                            email: string;
                            locator: string;
                        } | {
                            type: 'phone';
                            phone: string;
                            locator: string;
                        };
                        /**
                         * The message that was signed
                         */
                        message: string;
                        /**
                         * Additional metadata about the signature submission
                         */
                        metadata?: {
                            deviceInfo?: string;
                            ipAddress?: string;
                            userAgent?: string;
                        };
                    }>;
                    /**
                     * Number of required approvals for the transaction
                     */
                    required?: number;
                };
                /**
                 * ISO timestamp when the transaction was created
                 */
                createdAt: number | string;
                /**
                 * ISO timestamp when the transaction reached finality
                 */
                completedAt?: number | string;
                /**
                 * Error message if the transaction fails after submission
                 */
                error?: {
                    reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
                    message: string;
                } | {
                    reason: 'program_error';
                    message: string;
                    logs?: unknown;
                } | {
                    reason: 'execution_reverted';
                    message: string;
                    revert?: {
                        type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                        reason: string;
                        reasonData?: string | {
                            [key: string]: unknown;
                        };
                        explorerLink?: string;
                        simulationLink?: string;
                    };
                };
                sendParams?: {
                    /**
                     * The token locator that's being sent
                     */
                    token: string;
                    /**
                     * The parameters for the send token transaction
                     */
                    params: {
                        /**
                         * The amount of the token to send
                         */
                        amount?: string;
                        /**
                         * The recipient locator for the token
                         */
                        recipient: string;
                        /**
                         * The recipient address for the token
                         */
                        recipientAddress: string;
                    };
                };
                walletType: 'smart';
            };
        }>;
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that owns this wallet in format <locatorType>:<value>
     */
    owner?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number | string;
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'aptos';
    /**
     * The wallet type (smart or mpc)
     */
    type: 'smart' | 'mpc';
    /**
     * Aptos wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that owns this wallet in format <locatorType>:<value>
     */
    owner?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number | string;
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'sui';
    /**
     * The wallet type (smart or mpc)
     */
    type: 'smart' | 'mpc';
    /**
     * Sui wallet type specific configuration settings
     */
    config?: unknown;
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that owns this wallet in format <locatorType>:<value>
     */
    owner?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number | string;
} | {
    /**
     * The blockchain type of the wallet
     */
    chainType: 'stellar';
    /**
     * The wallet type (smart or mpc)
     */
    type: 'smart' | 'mpc';
    /**
     * Stellar wallet type specific configuration settings
     */
    config?: {
        adminSigner: {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        };
        /**
         * Delegated Signer Response
         * Complete delegated signer response including the signer and authorization transaction
         */
        delegatedSigners?: Array<({
            /**
             * Identifier for the Passkey signer type
             */
            type: 'passkey';
            /**
             * Credential ID from the WebAuthn registration response
             */
            id: string;
            /**
             * Human-readable name for the passkey
             */
            name: string;
            /**
             * The public key coordinates from the WebAuthn credential
             */
            publicKey: {
                /**
                 * X coordinate of the public key as a decimal string
                 */
                x: string;
                /**
                 * Y coordinate of the public key as a decimal string
                 */
                y: string;
            };
            /**
             * ERC-7579 webAuthn validator contract version
             */
            validatorContractVersion: string;
            /**
             * Unique identifier for locating this passkey signer
             */
            locator: string;
        } | {
            /**
             * Identifier for API key signer type
             */
            type: 'api-key';
            /**
             * The blockchain address of the custodial signer
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for external wallet signer type
             */
            type: 'external-wallet';
            /**
             * The blockchain address of the external wallet
             */
            address: string;
            /**
             * The locator of the signer
             */
            locator: string;
        } | {
            /**
             * Identifier for email signer type
             */
            type: 'email';
            /**
             * The email address for the signer
             */
            email: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        } | {
            /**
             * Identifier for phone signer type
             */
            type: 'phone';
            /**
             * The phone number for the signer in E164 format
             */
            phone: string;
            /**
             * The locator of the signer
             */
            locator: string;
            /**
             * The address of the signer
             */
            address: string;
        }) & {
            /**
             * Optional array of permissions to be used for the signer
             */
            permissions?: Array<{
                type: 'external-policy';
                address: string;
            }>;
            /**
             * The transaction for the signer
             */
            transaction?: {
                chainType: 'stellar';
                /**
                 * Stellar on-chain data
                 */
                onChain: {
                    /**
                     * Stellar on-chain transaction
                     * The Stellar Transaction Envelope
                     */
                    transaction: {
                        method: string;
                        tx: string;
                    };
                    /**
                     * The transaction hash
                     */
                    txId?: string;
                    /**
                     * The ledger number where the transaction was included
                     */
                    ledger?: number;
                    /**
                     * The expiration of the transaction
                     */
                    expiration: number;
                    /**
                     * The Transaction Result in XDR format
                     */
                    result?: unknown;
                    /**
                     * Optional link to view the transaction in an explorer
                     */
                    explorerLink?: string;
                };
                /**
                 * Unique identifier for the transaction
                 */
                id: string;
                /**
                 * Current status of the transaction
                 */
                status: 'awaiting-approval' | 'pending' | 'failed' | 'success';
                /**
                 * Complete approval data including requirements, pending and submitted signatures
                 */
                approvals?: {
                    /**
                     * List of pending signatures
                     */
                    pending: Array<{
                        /**
                         * The full signer object that's pending approval
                         */
                        signer: {
                            type: 'external-wallet';
                            /**
                             * The address of the external wallet
                             */
                            address: string;
                            /**
                             * The locator of the external wallet signer
                             */
                            locator: string;
                        } | {
                            type: 'passkey';
                            /**
                             * The ID of the passkey
                             */
                            id: string;
                            /**
                             * The locator of the passkey signer
                             */
                            locator: string;
                        } | {
                            type: 'api-key';
                            /**
                             * The address of the api key
                             */
                            address: string;
                            /**
                             * The locator of the api key signer
                             */
                            locator: string;
                        } | {
                            type: 'email';
                            email: string;
                            locator: string;
                        } | {
                            type: 'phone';
                            phone: string;
                            locator: string;
                        };
                        /**
                         * The message that needs to be signed
                         */
                        message: string;
                    }>;
                    /**
                     * Record of all submitted signatures
                     */
                    submitted: Array<{
                        /**
                         * The cryptographic signature
                         */
                        signature: string;
                        /**
                         * When the signature was submitted
                         */
                        submittedAt: number | string;
                        /**
                         * The full signer object who submitted this signature
                         */
                        signer: {
                            type: 'external-wallet';
                            /**
                             * The address of the external wallet
                             */
                            address: string;
                            /**
                             * The locator of the external wallet signer
                             */
                            locator: string;
                        } | {
                            type: 'passkey';
                            /**
                             * The ID of the passkey
                             */
                            id: string;
                            /**
                             * The locator of the passkey signer
                             */
                            locator: string;
                        } | {
                            type: 'api-key';
                            /**
                             * The address of the api key
                             */
                            address: string;
                            /**
                             * The locator of the api key signer
                             */
                            locator: string;
                        } | {
                            type: 'email';
                            email: string;
                            locator: string;
                        } | {
                            type: 'phone';
                            phone: string;
                            locator: string;
                        };
                        /**
                         * The message that was signed
                         */
                        message: string;
                        /**
                         * Additional metadata about the signature submission
                         */
                        metadata?: {
                            deviceInfo?: string;
                            ipAddress?: string;
                            userAgent?: string;
                        };
                    }>;
                    /**
                     * Number of required approvals for the transaction
                     */
                    required?: number;
                };
                /**
                 * ISO timestamp when the transaction was created
                 */
                createdAt: number | string;
                /**
                 * ISO timestamp when the transaction reached finality
                 */
                completedAt?: number | string;
                /**
                 * Error message if the transaction fails after submission
                 */
                error?: {
                    reason: 'build_failed' | 'failed_to_land_on_chain' | 'unknown' | 'sanctioned_wallet_address';
                    message: string;
                } | {
                    reason: 'program_error';
                    message: string;
                    logs?: unknown;
                } | {
                    reason: 'execution_reverted';
                    message: string;
                    revert?: {
                        type: 'contract_call' | 'wallet_authorization' | 'wallet_deployment';
                        reason: string;
                        reasonData?: string | {
                            [key: string]: unknown;
                        };
                        explorerLink?: string;
                        simulationLink?: string;
                    };
                };
                sendParams?: {
                    /**
                     * The token locator that's being sent
                     */
                    token: string;
                    /**
                     * The parameters for the send token transaction
                     */
                    params: {
                        /**
                         * The amount of the token to send
                         */
                        amount?: string;
                        /**
                         * The recipient locator for the token
                         */
                        recipient: string;
                        /**
                         * The recipient address for the token
                         */
                        recipientAddress: string;
                    };
                };
                walletType: 'smart';
            };
        }>;
        /**
         * Optional array of plugins used for the wallet
         */
        plugins?: Array<string>;
    };
    /**
     * The onchain address of the wallet
     */
    address: string;
    /**
     * The user that owns this wallet in format <locatorType>:<value>
     */
    owner?: string;
    /**
     * ISO timestamp of when the wallet was created
     */
    createdAt?: number | string;
};
type WalletsV1ControllerSubmitMeApprovals5Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        transactionId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals';
};
type WalletsV1ControllerSubmitMeApprovals5Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitMeApprovals5Error = WalletsV1ControllerSubmitMeApprovals5Errors[keyof WalletsV1ControllerSubmitMeApprovals5Errors];
type WalletsV1ControllerSubmitMeApprovals5Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerSubmitMeApprovals5Response = WalletsV1ControllerSubmitMeApprovals5Responses[keyof WalletsV1ControllerSubmitMeApprovals5Responses];
type WalletsV1ControllerGetMeTransaction5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        transactionId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}';
};
type WalletsV1ControllerGetMeTransaction5Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeTransaction5Error = WalletsV1ControllerGetMeTransaction5Errors[keyof WalletsV1ControllerGetMeTransaction5Errors];
type WalletsV1ControllerGetMeTransaction5Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerGetMeTransaction5Response = WalletsV1ControllerGetMeTransaction5Responses[keyof WalletsV1ControllerGetMeTransaction5Responses];
type WalletsV1ControllerGetMeTransactionsWithoutChain5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/v1-alpha2/wallets/me{walletType}/transactions';
};
type WalletsV1ControllerGetMeTransactionsWithoutChain5Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeTransactionsWithoutChain5Error = WalletsV1ControllerGetMeTransactionsWithoutChain5Errors[keyof WalletsV1ControllerGetMeTransactionsWithoutChain5Errors];
type WalletsV1ControllerGetMeTransactionsWithoutChain5Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionsResponseDto;
};
type WalletsV1ControllerGetMeTransactionsWithoutChain5Response = WalletsV1ControllerGetMeTransactionsWithoutChain5Responses[keyof WalletsV1ControllerGetMeTransactionsWithoutChain5Responses];
type WalletsV1ControllerCreateMeTransaction5Data = {
    body: CreateTransactionDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        'x-idempotency-key': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/transactions';
};
type WalletsV1ControllerCreateMeTransaction5Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified type is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};
type WalletsV1ControllerCreateMeTransaction5Error = WalletsV1ControllerCreateMeTransaction5Errors[keyof WalletsV1ControllerCreateMeTransaction5Errors];
type WalletsV1ControllerCreateMeTransaction5Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerCreateMeTransaction5Response = WalletsV1ControllerCreateMeTransaction5Responses[keyof WalletsV1ControllerCreateMeTransaction5Responses];
type WalletsV1ControllerGetMeDelegatedSigner5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        /**
         * Signer Locator
         * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
         */
        signer: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/signers/{signer}';
};
type WalletsV1ControllerGetMeDelegatedSigner5Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeDelegatedSigner5Error = WalletsV1ControllerGetMeDelegatedSigner5Errors[keyof WalletsV1ControllerGetMeDelegatedSigner5Errors];
type WalletsV1ControllerGetMeDelegatedSigner5Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerDto;
};
type WalletsV1ControllerGetMeDelegatedSigner5Response = WalletsV1ControllerGetMeDelegatedSigner5Responses[keyof WalletsV1ControllerGetMeDelegatedSigner5Responses];
type WalletsV1ControllerCreateMeDelegatedSigner5Data = {
    body: CreateSignerInputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/signers';
};
type WalletsV1ControllerCreateMeDelegatedSigner5Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateMeDelegatedSigner5Error = WalletsV1ControllerCreateMeDelegatedSigner5Errors[keyof WalletsV1ControllerCreateMeDelegatedSigner5Errors];
type WalletsV1ControllerCreateMeDelegatedSigner5Responses = {
    /**
     * The delegated signer has been successfully added to the wallet.
     */
    201: DelegatedSignerDto;
};
type WalletsV1ControllerCreateMeDelegatedSigner5Response = WalletsV1ControllerCreateMeDelegatedSigner5Responses[keyof WalletsV1ControllerCreateMeDelegatedSigner5Responses];
type WalletsV1ControllerSubmitMeSignatureApprovals5Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        signatureId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals';
};
type WalletsV1ControllerSubmitMeSignatureApprovals5Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitMeSignatureApprovals5Error = WalletsV1ControllerSubmitMeSignatureApprovals5Errors[keyof WalletsV1ControllerSubmitMeSignatureApprovals5Errors];
type WalletsV1ControllerSubmitMeSignatureApprovals5Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerSubmitMeSignatureApprovals5Response = WalletsV1ControllerSubmitMeSignatureApprovals5Responses[keyof WalletsV1ControllerSubmitMeSignatureApprovals5Responses];
type WalletsV1ControllerGetMeSignature5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        signatureId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}';
};
type WalletsV1ControllerGetMeSignature5Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeSignature5Error = WalletsV1ControllerGetMeSignature5Errors[keyof WalletsV1ControllerGetMeSignature5Errors];
type WalletsV1ControllerGetMeSignature5Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerGetMeSignature5Response = WalletsV1ControllerGetMeSignature5Responses[keyof WalletsV1ControllerGetMeSignature5Responses];
type WalletsV1ControllerCreateMeSignatureRequest5Data = {
    body: CreateSignatureRequestDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}/signatures';
};
type WalletsV1ControllerCreateMeSignatureRequest5Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateMeSignatureRequest5Error = WalletsV1ControllerCreateMeSignatureRequest5Errors[keyof WalletsV1ControllerCreateMeSignatureRequest5Errors];
type WalletsV1ControllerCreateMeSignatureRequest5Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerCreateMeSignatureRequest5Response = WalletsV1ControllerCreateMeSignatureRequest5Responses[keyof WalletsV1ControllerCreateMeSignatureRequest5Responses];
type WalletsV1ControllerGetMeWalletActivity5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query: {
        /**
         * The blockchain network to query. Either an EVM chain, Solana, or Stellar.
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow' | 'solana' | 'stellar';
    };
    url: '/v1-alpha2/wallets/me{walletType}/activity';
};
type WalletsV1ControllerGetMeWalletActivity5Errors = {
    /**
     * Returns an error if a wallet with the specified type not found for the authenticated user
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeWalletActivity5Error = WalletsV1ControllerGetMeWalletActivity5Errors[keyof WalletsV1ControllerGetMeWalletActivity5Errors];
type WalletsV1ControllerGetMeWalletActivity5Responses = {
    /**
     * The wallet activity has been successfully retrieved.
     */
    200: WalletsV1Alpha2ActivityResponseDto;
};
type WalletsV1ControllerGetMeWalletActivity5Response = WalletsV1ControllerGetMeWalletActivity5Responses[keyof WalletsV1ControllerGetMeWalletActivity5Responses];
type WalletsV1ControllerGetMeWallet5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/me{walletType}';
};
type WalletsV1ControllerGetMeWallet5Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerGetMeWallet5Response = WalletsV1ControllerGetMeWallet5Responses[keyof WalletsV1ControllerGetMeWallet5Responses];
type WalletsV1ControllerCreateMeWallet5Data = {
    body: CreateWalletDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path?: never;
    query?: never;
    url: '/v1-alpha2/wallets/me';
};
type WalletsV1ControllerCreateMeWallet5Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for this user, or creates and returns a new wallet (201).
     */
    201: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerCreateMeWallet5Response = WalletsV1ControllerCreateMeWallet5Responses[keyof WalletsV1ControllerCreateMeWallet5Responses];
type WalletsV1ControllerSubmitApprovals5Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals';
};
type WalletsV1ControllerSubmitApprovals5Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitApprovals5Error = WalletsV1ControllerSubmitApprovals5Errors[keyof WalletsV1ControllerSubmitApprovals5Errors];
type WalletsV1ControllerSubmitApprovals5Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerSubmitApprovals5Response = WalletsV1ControllerSubmitApprovals5Responses[keyof WalletsV1ControllerSubmitApprovals5Responses];
type WalletsV1ControllerGetTransaction5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}';
};
type WalletsV1ControllerGetTransaction5Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetTransaction5Error = WalletsV1ControllerGetTransaction5Errors[keyof WalletsV1ControllerGetTransaction5Errors];
type WalletsV1ControllerGetTransaction5Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerGetTransaction5Response = WalletsV1ControllerGetTransaction5Responses[keyof WalletsV1ControllerGetTransaction5Responses];
type WalletsV1ControllerGetTransactionsWithoutChain5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/v1-alpha2/wallets/{walletLocator}/transactions';
};
type WalletsV1ControllerGetTransactionsWithoutChain5Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetTransactionsWithoutChain5Error = WalletsV1ControllerGetTransactionsWithoutChain5Errors[keyof WalletsV1ControllerGetTransactionsWithoutChain5Errors];
type WalletsV1ControllerGetTransactionsWithoutChain5Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionsResponseDto;
};
type WalletsV1ControllerGetTransactionsWithoutChain5Response = WalletsV1ControllerGetTransactionsWithoutChain5Responses[keyof WalletsV1ControllerGetTransactionsWithoutChain5Responses];
type WalletsV1ControllerCreateTransaction5Data = {
    body: CreateTransactionDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/transactions';
};
type WalletsV1ControllerCreateTransaction5Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};
type WalletsV1ControllerCreateTransaction5Error = WalletsV1ControllerCreateTransaction5Errors[keyof WalletsV1ControllerCreateTransaction5Errors];
type WalletsV1ControllerCreateTransaction5Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerCreateTransaction5Response = WalletsV1ControllerCreateTransaction5Responses[keyof WalletsV1ControllerCreateTransaction5Responses];
type WalletsV1ControllerGetDelegatedSigner5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        /**
         * Signer Locator
         * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
         */
        signer: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/signers/{signer}';
};
type WalletsV1ControllerGetDelegatedSigner5Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetDelegatedSigner5Error = WalletsV1ControllerGetDelegatedSigner5Errors[keyof WalletsV1ControllerGetDelegatedSigner5Errors];
type WalletsV1ControllerGetDelegatedSigner5Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerDto;
};
type WalletsV1ControllerGetDelegatedSigner5Response = WalletsV1ControllerGetDelegatedSigner5Responses[keyof WalletsV1ControllerGetDelegatedSigner5Responses];
type WalletsV1ControllerCreateDelegatedSigner5Data = {
    body: CreateSignerInputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/signers';
};
type WalletsV1ControllerCreateDelegatedSigner5Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateDelegatedSigner5Error = WalletsV1ControllerCreateDelegatedSigner5Errors[keyof WalletsV1ControllerCreateDelegatedSigner5Errors];
type WalletsV1ControllerCreateDelegatedSigner5Responses = {
    /**
     * The delegated signer has been successfully added to the wallet.
     */
    201: DelegatedSignerDto;
};
type WalletsV1ControllerCreateDelegatedSigner5Response = WalletsV1ControllerCreateDelegatedSigner5Responses[keyof WalletsV1ControllerCreateDelegatedSigner5Responses];
type WalletsV1ControllerSubmitSignatureApprovals5Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals';
};
type WalletsV1ControllerSubmitSignatureApprovals5Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitSignatureApprovals5Error = WalletsV1ControllerSubmitSignatureApprovals5Errors[keyof WalletsV1ControllerSubmitSignatureApprovals5Errors];
type WalletsV1ControllerSubmitSignatureApprovals5Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerSubmitSignatureApprovals5Response = WalletsV1ControllerSubmitSignatureApprovals5Responses[keyof WalletsV1ControllerSubmitSignatureApprovals5Responses];
type WalletsV1ControllerGetSignature5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}';
};
type WalletsV1ControllerGetSignature5Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetSignature5Error = WalletsV1ControllerGetSignature5Errors[keyof WalletsV1ControllerGetSignature5Errors];
type WalletsV1ControllerGetSignature5Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerGetSignature5Response = WalletsV1ControllerGetSignature5Responses[keyof WalletsV1ControllerGetSignature5Responses];
type WalletsV1ControllerGetAllSignatures5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/v1-alpha2/wallets/{walletLocator}/signatures';
};
type WalletsV1ControllerGetAllSignatures5Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetAllSignatures5Error = WalletsV1ControllerGetAllSignatures5Errors[keyof WalletsV1ControllerGetAllSignatures5Errors];
type WalletsV1ControllerGetAllSignatures5Responses = {
    /**
     * The signatures have been successfully retrieved.
     */
    200: WalletsV1Alpha2MultipleSignatureResponseDto;
};
type WalletsV1ControllerGetAllSignatures5Response = WalletsV1ControllerGetAllSignatures5Responses[keyof WalletsV1ControllerGetAllSignatures5Responses];
type WalletsV1ControllerCreateSignatureRequest5Data = {
    body: CreateSignatureRequestDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/signatures';
};
type WalletsV1ControllerCreateSignatureRequest5Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateSignatureRequest5Error = WalletsV1ControllerCreateSignatureRequest5Errors[keyof WalletsV1ControllerCreateSignatureRequest5Errors];
type WalletsV1ControllerCreateSignatureRequest5Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerCreateSignatureRequest5Response = WalletsV1ControllerCreateSignatureRequest5Responses[keyof WalletsV1ControllerCreateSignatureRequest5Responses];
type BalanceControllerGetBalanceForLocator2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain(s) to query. Comma-separated list of chains
         */
        chains?: string;
        /**
         * The tokens to query. Comma-separated list
         */
        tokens: string;
    };
    url: '/v1-alpha2/wallets/{walletLocator}/balances';
};
type BalanceControllerGetBalanceForLocator2Errors = {
    /**
     * Returns an error (400) if the wallet locator is invalid or if the address type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
};
type BalanceControllerGetBalanceForLocator2Error = BalanceControllerGetBalanceForLocator2Errors[keyof BalanceControllerGetBalanceForLocator2Errors];
type BalanceControllerGetBalanceForLocator2Responses = {
    /**
     * Returns the balance of the wallet for the given chain and currency
     */
    200: WalletBalanceResponseDto;
};
type BalanceControllerGetBalanceForLocator2Response = BalanceControllerGetBalanceForLocator2Responses[keyof BalanceControllerGetBalanceForLocator2Responses];
type BalanceControllerFundWallet2Data = {
    body: FundWalletAmountDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}/balances';
};
type BalanceControllerFundWallet2Errors = {
    /**
     * Returns an error (404) if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type BalanceControllerFundWallet2Error = BalanceControllerFundWallet2Errors[keyof BalanceControllerFundWallet2Errors];
type BalanceControllerFundWallet2Responses = {
    /**
     * Funds sent successfully.
     */
    201: WalletBalanceResponseDto;
};
type BalanceControllerFundWallet2Response = BalanceControllerFundWallet2Responses[keyof BalanceControllerFundWallet2Responses];
type WalletsV1ControllerGetWalletActivity5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain network to query. Either an EVM chain, Solana, or Stellar.
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow' | 'solana' | 'stellar';
    };
    url: '/v1-alpha2/wallets/{walletLocator}/activity';
};
type WalletsV1ControllerGetWalletActivity5Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetWalletActivity5Error = WalletsV1ControllerGetWalletActivity5Errors[keyof WalletsV1ControllerGetWalletActivity5Errors];
type WalletsV1ControllerGetWalletActivity5Responses = {
    /**
     * The wallet activity has been successfully retrieved.
     */
    200: WalletsV1Alpha2ActivityResponseDto;
};
type WalletsV1ControllerGetWalletActivity5Response = WalletsV1ControllerGetWalletActivity5Responses[keyof WalletsV1ControllerGetWalletActivity5Responses];
type WalletsV1ControllerGetWalletByLocator5Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/v1-alpha2/wallets/{walletLocator}';
};
type WalletsV1ControllerGetWalletByLocator5Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetWalletByLocator5Error = WalletsV1ControllerGetWalletByLocator5Errors[keyof WalletsV1ControllerGetWalletByLocator5Errors];
type WalletsV1ControllerGetWalletByLocator5Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerGetWalletByLocator5Response = WalletsV1ControllerGetWalletByLocator5Responses[keyof WalletsV1ControllerGetWalletByLocator5Responses];
type WalletsV1ControllerCreateWallet5Data = {
    body: CreateWalletDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate wallet creation
         */
        'x-idempotency-key'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1-alpha2/wallets';
};
type WalletsV1ControllerCreateWallet5Errors = {
    /**
     * Returns an error if a wallet with the specified creation seed and signer configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateWallet5Error = WalletsV1ControllerCreateWallet5Errors[keyof WalletsV1ControllerCreateWallet5Errors];
type WalletsV1ControllerCreateWallet5Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for the provided linkedUser or idempotencyKey, or creates and returns a new wallet (201). The response includes the wallet details and whether it was newly created.
     */
    201: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerCreateWallet5Response = WalletsV1ControllerCreateWallet5Responses[keyof WalletsV1ControllerCreateWallet5Responses];
type WalletsSendTokenControllerSendMeToken2Data = {
    body: SendTokenDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        walletType: string;
        /**
         * A token locator that supports native tokens, fungible tokens, and NFTs across different chains. It can be of the format:
         * - `chain:address[:tokenId]`
         * - `chain:currency`
         * - `chain:address`
         */
        tokenLocator: string;
    };
    query?: never;
    url: '/unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers';
};
type WalletsSendTokenControllerSendMeToken2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsSendTokenControllerSendMeToken2Response = WalletsSendTokenControllerSendMeToken2Responses[keyof WalletsSendTokenControllerSendMeToken2Responses];
type WalletActivityUnstableControllerGetMeWalletActivity2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain network to query. Either an EVM chain, Solana, or Stellar.
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow' | 'solana' | 'stellar';
    };
    url: '/unstable/wallets/me{walletLocator}/activity';
};
type WalletActivityUnstableControllerGetMeWalletActivity2Errors = {
    /**
     * Returns an error if a wallet with the specified type not found for the authenticated user
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletActivityUnstableControllerGetMeWalletActivity2Error = WalletActivityUnstableControllerGetMeWalletActivity2Errors[keyof WalletActivityUnstableControllerGetMeWalletActivity2Errors];
type WalletActivityUnstableControllerGetMeWalletActivity2Responses = {
    /**
     * The wallet activity has been successfully retrieved.
     */
    200: WalletsActivityResponseUnstableDto;
};
type WalletActivityUnstableControllerGetMeWalletActivity2Response = WalletActivityUnstableControllerGetMeWalletActivity2Responses[keyof WalletActivityUnstableControllerGetMeWalletActivity2Responses];
type WalletsSendTokenControllerSendToken2Data = {
    body: SendTokenDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        /**
         * A token locator that supports native tokens, fungible tokens, and NFTs across different chains. It can be of the format:
         * - `chain:address[:tokenId]`
         * - `chain:currency`
         * - `chain:address`
         */
        tokenLocator: string;
    };
    query?: never;
    url: '/unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers';
};
type WalletsSendTokenControllerSendToken2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseWithSendParamsDto;
};
type WalletsSendTokenControllerSendToken2Response = WalletsSendTokenControllerSendToken2Responses[keyof WalletsSendTokenControllerSendToken2Responses];
type BalanceUnstableControllerGetBalanceForLocator2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain(s) to query. Comma-separated list of chains
         */
        chains?: string;
        /**
         * The tokens to query. Comma-separated list of either tokens or token locator strings
         */
        tokens: string;
    };
    url: '/unstable/wallets/{walletLocator}/balances';
};
type BalanceUnstableControllerGetBalanceForLocator2Errors = {
    /**
     * Returns an error (400) if the wallet locator is invalid or if the address type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
};
type BalanceUnstableControllerGetBalanceForLocator2Error = BalanceUnstableControllerGetBalanceForLocator2Errors[keyof BalanceUnstableControllerGetBalanceForLocator2Errors];
type BalanceUnstableControllerGetBalanceForLocator2Responses = {
    /**
     * Returns the balance of the wallet for the given chain and currency
     */
    200: WalletBalanceUnstableResponseDto;
};
type BalanceUnstableControllerGetBalanceForLocator2Response = BalanceUnstableControllerGetBalanceForLocator2Responses[keyof BalanceUnstableControllerGetBalanceForLocator2Responses];
type WalletActivityUnstableControllerGetWalletActivity2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain network to query. Either an EVM chain, Solana, or Stellar.
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow' | 'solana' | 'stellar';
    };
    url: '/unstable/wallets/{walletLocator}/activity';
};
type WalletActivityUnstableControllerGetWalletActivity2Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletActivityUnstableControllerGetWalletActivity2Error = WalletActivityUnstableControllerGetWalletActivity2Errors[keyof WalletActivityUnstableControllerGetWalletActivity2Errors];
type WalletActivityUnstableControllerGetWalletActivity2Responses = {
    /**
     * The wallet activity has been successfully retrieved.
     */
    200: WalletsActivityResponseUnstableDto;
};
type WalletActivityUnstableControllerGetWalletActivity2Response = WalletActivityUnstableControllerGetWalletActivity2Responses[keyof WalletActivityUnstableControllerGetWalletActivity2Responses];
type WalletsV2025ControllerSubmitMeApprovals2Data = {
    body: SubmitApprovalV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals';
};
type WalletsV2025ControllerSubmitMeApprovals2Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerSubmitMeApprovals2Error = WalletsV2025ControllerSubmitMeApprovals2Errors[keyof WalletsV2025ControllerSubmitMeApprovals2Errors];
type WalletsV2025ControllerSubmitMeApprovals2Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsTransactionV2025ResponseDto;
};
type WalletsV2025ControllerSubmitMeApprovals2Response = WalletsV2025ControllerSubmitMeApprovals2Responses[keyof WalletsV2025ControllerSubmitMeApprovals2Responses];
type WalletsV2025ControllerGetMeTransaction2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}';
};
type WalletsV2025ControllerGetMeTransaction2Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetMeTransaction2Error = WalletsV2025ControllerGetMeTransaction2Errors[keyof WalletsV2025ControllerGetMeTransaction2Errors];
type WalletsV2025ControllerGetMeTransaction2Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsTransactionV2025ResponseDto;
};
type WalletsV2025ControllerGetMeTransaction2Response = WalletsV2025ControllerGetMeTransaction2Responses[keyof WalletsV2025ControllerGetMeTransaction2Responses];
type WalletsV2025ControllerGetMeTransactionsWithoutChain2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2025-06-09/wallets/me{walletLocator}/transactions';
};
type WalletsV2025ControllerGetMeTransactionsWithoutChain2Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetMeTransactionsWithoutChain2Error = WalletsV2025ControllerGetMeTransactionsWithoutChain2Errors[keyof WalletsV2025ControllerGetMeTransactionsWithoutChain2Errors];
type WalletsV2025ControllerGetMeTransactionsWithoutChain2Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsMultipleTransactionV2025ResponseDto;
};
type WalletsV2025ControllerGetMeTransactionsWithoutChain2Response = WalletsV2025ControllerGetMeTransactionsWithoutChain2Responses[keyof WalletsV2025ControllerGetMeTransactionsWithoutChain2Responses];
type WalletsV2025ControllerCreateMeTransaction2Data = {
    body: CreateTransactionV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        'x-idempotency-key': string;
    };
    path: {
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/transactions';
};
type WalletsV2025ControllerCreateMeTransaction2Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified type is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};
type WalletsV2025ControllerCreateMeTransaction2Error = WalletsV2025ControllerCreateMeTransaction2Errors[keyof WalletsV2025ControllerCreateMeTransaction2Errors];
type WalletsV2025ControllerCreateMeTransaction2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsTransactionV2025ResponseDto;
};
type WalletsV2025ControllerCreateMeTransaction2Response = WalletsV2025ControllerCreateMeTransaction2Responses[keyof WalletsV2025ControllerCreateMeTransaction2Responses];
type WalletsSendTokenV2025ControllerSendMeToken2Data = {
    body: SendTokenV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        walletLocator: string;
        /**
         * A token locator that supports native tokens, fungible tokens, and NFTs across different chains. It can be of the format:
         * - `chain:address[:tokenId]`
         * - `chain:currency`
         * - `chain:address`
         */
        tokenLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers';
};
type WalletsSendTokenV2025ControllerSendMeToken2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsTransactionV2025ResponseDto;
};
type WalletsSendTokenV2025ControllerSendMeToken2Response = WalletsSendTokenV2025ControllerSendMeToken2Responses[keyof WalletsSendTokenV2025ControllerSendMeToken2Responses];
type WalletsV2025ControllerGetMeDelegatedSigner2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
        /**
         * Signer Locator
         * The locator for the signer
         */
        signer: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/signers/{signer}';
};
type WalletsV2025ControllerGetMeDelegatedSigner2Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetMeDelegatedSigner2Error = WalletsV2025ControllerGetMeDelegatedSigner2Errors[keyof WalletsV2025ControllerGetMeDelegatedSigner2Errors];
type WalletsV2025ControllerGetMeDelegatedSigner2Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerV2025Dto;
};
type WalletsV2025ControllerGetMeDelegatedSigner2Response = WalletsV2025ControllerGetMeDelegatedSigner2Responses[keyof WalletsV2025ControllerGetMeDelegatedSigner2Responses];
type WalletsV2025ControllerCreateMeDelegatedSigner2Data = {
    body: CreateSignerV2025InputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/signers';
};
type WalletsV2025ControllerCreateMeDelegatedSigner2Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerCreateMeDelegatedSigner2Error = WalletsV2025ControllerCreateMeDelegatedSigner2Errors[keyof WalletsV2025ControllerCreateMeDelegatedSigner2Errors];
type WalletsV2025ControllerCreateMeDelegatedSigner2Responses = {
    /**
     * The delegated signer has been successfully added to the wallet.
     */
    201: DelegatedSignerV2025Dto;
};
type WalletsV2025ControllerCreateMeDelegatedSigner2Response = WalletsV2025ControllerCreateMeDelegatedSigner2Responses[keyof WalletsV2025ControllerCreateMeDelegatedSigner2Responses];
type WalletsV2025ControllerSubmitMeSignatureApprovals2Data = {
    body: SubmitApprovalV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals';
};
type WalletsV2025ControllerSubmitMeSignatureApprovals2Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerSubmitMeSignatureApprovals2Error = WalletsV2025ControllerSubmitMeSignatureApprovals2Errors[keyof WalletsV2025ControllerSubmitMeSignatureApprovals2Errors];
type WalletsV2025ControllerSubmitMeSignatureApprovals2Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsSignatureV2025ResponseDto;
};
type WalletsV2025ControllerSubmitMeSignatureApprovals2Response = WalletsV2025ControllerSubmitMeSignatureApprovals2Responses[keyof WalletsV2025ControllerSubmitMeSignatureApprovals2Responses];
type WalletsV2025ControllerGetMeSignature2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}';
};
type WalletsV2025ControllerGetMeSignature2Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetMeSignature2Error = WalletsV2025ControllerGetMeSignature2Errors[keyof WalletsV2025ControllerGetMeSignature2Errors];
type WalletsV2025ControllerGetMeSignature2Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsSignatureV2025ResponseDto;
};
type WalletsV2025ControllerGetMeSignature2Response = WalletsV2025ControllerGetMeSignature2Responses[keyof WalletsV2025ControllerGetMeSignature2Responses];
type WalletsV2025ControllerGetMeSignatures2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2025-06-09/wallets/me{walletLocator}/signatures';
};
type WalletsV2025ControllerGetMeSignatures2Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetMeSignatures2Error = WalletsV2025ControllerGetMeSignatures2Errors[keyof WalletsV2025ControllerGetMeSignatures2Errors];
type WalletsV2025ControllerGetMeSignatures2Responses = {
    /**
     * The signatures have been successfully retrieved.
     */
    200: WalletsMultipleSignatureV2025ResponseDto;
};
type WalletsV2025ControllerGetMeSignatures2Response = WalletsV2025ControllerGetMeSignatures2Responses[keyof WalletsV2025ControllerGetMeSignatures2Responses];
type WalletsV2025ControllerCreateMeSignatureRequest2Data = {
    body: CreateSignatureV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        'x-idempotency-key': string;
    };
    path: {
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}/signatures';
};
type WalletsV2025ControllerCreateMeSignatureRequest2Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerCreateMeSignatureRequest2Error = WalletsV2025ControllerCreateMeSignatureRequest2Errors[keyof WalletsV2025ControllerCreateMeSignatureRequest2Errors];
type WalletsV2025ControllerCreateMeSignatureRequest2Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsSignatureV2025ResponseDto;
};
type WalletsV2025ControllerCreateMeSignatureRequest2Response = WalletsV2025ControllerCreateMeSignatureRequest2Responses[keyof WalletsV2025ControllerCreateMeSignatureRequest2Responses];
type WalletsV2025ControllerGetMeWallet2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/me{walletLocator}';
};
type WalletsV2025ControllerGetMeWallet2Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV2025ResponseDto;
};
type WalletsV2025ControllerGetMeWallet2Response = WalletsV2025ControllerGetMeWallet2Responses[keyof WalletsV2025ControllerGetMeWallet2Responses];
type WalletsV2025ControllerCreateMeWallet2Data = {
    body: CreateWalletV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path?: never;
    query?: never;
    url: '/2025-06-09/wallets/me';
};
type WalletsV2025ControllerCreateMeWallet2Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for this user, or creates and returns a new wallet (201).
     */
    201: WalletV2025ResponseDto;
};
type WalletsV2025ControllerCreateMeWallet2Response = WalletsV2025ControllerCreateMeWallet2Responses[keyof WalletsV2025ControllerCreateMeWallet2Responses];
type WalletsV2025ControllerGetPayoutTransaction2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        transactionId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/CROSSMINT/transactions/{transactionId}';
};
type WalletsV2025ControllerGetPayoutTransaction2Errors = {
    /**
     * Returns an error if the payout transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetPayoutTransaction2Error = WalletsV2025ControllerGetPayoutTransaction2Errors[keyof WalletsV2025ControllerGetPayoutTransaction2Errors];
type WalletsV2025ControllerGetPayoutTransaction2Responses = {
    /**
     * The payout transaction has been successfully retrieved.
     */
    200: SchemaHolderClass;
};
type WalletsV2025ControllerGetPayoutTransaction2Response = WalletsV2025ControllerGetPayoutTransaction2Responses[keyof WalletsV2025ControllerGetPayoutTransaction2Responses];
type WalletsSendTokenV2025ControllerCreatePayout2Data = {
    body: SendTokenV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A token locator that supports native tokens, fungible tokens, and NFTs across different chains. It can be of the format:
         * - `chain:address[:tokenId]`
         * - `chain:currency`
         * - `chain:address`
         */
        tokenLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/CROSSMINT/tokens/{tokenLocator}/transfers';
};
type WalletsSendTokenV2025ControllerCreatePayout2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: SchemaHolderClass;
};
type WalletsSendTokenV2025ControllerCreatePayout2Response = WalletsSendTokenV2025ControllerCreatePayout2Responses[keyof WalletsSendTokenV2025ControllerCreatePayout2Responses];
type WalletsV2025ControllerSubmitApprovals2Data = {
    body: SubmitApprovalV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals';
};
type WalletsV2025ControllerSubmitApprovals2Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerSubmitApprovals2Error = WalletsV2025ControllerSubmitApprovals2Errors[keyof WalletsV2025ControllerSubmitApprovals2Errors];
type WalletsV2025ControllerSubmitApprovals2Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsTransactionV2025ResponseDto;
};
type WalletsV2025ControllerSubmitApprovals2Response = WalletsV2025ControllerSubmitApprovals2Responses[keyof WalletsV2025ControllerSubmitApprovals2Responses];
type WalletsV2025ControllerGetTransaction2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}';
};
type WalletsV2025ControllerGetTransaction2Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetTransaction2Error = WalletsV2025ControllerGetTransaction2Errors[keyof WalletsV2025ControllerGetTransaction2Errors];
type WalletsV2025ControllerGetTransaction2Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsTransactionV2025ResponseDto;
};
type WalletsV2025ControllerGetTransaction2Response = WalletsV2025ControllerGetTransaction2Responses[keyof WalletsV2025ControllerGetTransaction2Responses];
type WalletsV2025ControllerGetTransactionsWithoutChain2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2025-06-09/wallets/{walletLocator}/transactions';
};
type WalletsV2025ControllerGetTransactionsWithoutChain2Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetTransactionsWithoutChain2Error = WalletsV2025ControllerGetTransactionsWithoutChain2Errors[keyof WalletsV2025ControllerGetTransactionsWithoutChain2Errors];
type WalletsV2025ControllerGetTransactionsWithoutChain2Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsMultipleTransactionV2025ResponseDto;
};
type WalletsV2025ControllerGetTransactionsWithoutChain2Response = WalletsV2025ControllerGetTransactionsWithoutChain2Responses[keyof WalletsV2025ControllerGetTransactionsWithoutChain2Responses];
type WalletsV2025ControllerCreateTransaction2Data = {
    body: CreateTransactionV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/transactions';
};
type WalletsV2025ControllerCreateTransaction2Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};
type WalletsV2025ControllerCreateTransaction2Error = WalletsV2025ControllerCreateTransaction2Errors[keyof WalletsV2025ControllerCreateTransaction2Errors];
type WalletsV2025ControllerCreateTransaction2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsTransactionV2025ResponseDto;
};
type WalletsV2025ControllerCreateTransaction2Response = WalletsV2025ControllerCreateTransaction2Responses[keyof WalletsV2025ControllerCreateTransaction2Responses];
type WalletsSendTokenV2025ControllerSendToken2Data = {
    body: SendOrDepositTokenV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        /**
         * A token locator that supports native tokens, fungible tokens, and NFTs across different chains. It can be of the format:
         * - `chain:address[:tokenId]`
         * - `chain:currency`
         * - `chain:address`
         */
        tokenLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers';
};
type WalletsSendTokenV2025ControllerSendToken2Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsTransactionV2025ResponseDto;
};
type WalletsSendTokenV2025ControllerSendToken2Response = WalletsSendTokenV2025ControllerSendToken2Responses[keyof WalletsSendTokenV2025ControllerSendToken2Responses];
type WalletsV2025ControllerGetDelegatedSigner2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        /**
         * Signer Locator
         * The locator for the signer
         */
        signer: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/signers/{signer}';
};
type WalletsV2025ControllerGetDelegatedSigner2Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetDelegatedSigner2Error = WalletsV2025ControllerGetDelegatedSigner2Errors[keyof WalletsV2025ControllerGetDelegatedSigner2Errors];
type WalletsV2025ControllerGetDelegatedSigner2Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerV2025Dto;
};
type WalletsV2025ControllerGetDelegatedSigner2Response = WalletsV2025ControllerGetDelegatedSigner2Responses[keyof WalletsV2025ControllerGetDelegatedSigner2Responses];
type WalletsV2025ControllerCreateDelegatedSigner2Data = {
    body: CreateSignerV2025InputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/signers';
};
type WalletsV2025ControllerCreateDelegatedSigner2Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerCreateDelegatedSigner2Error = WalletsV2025ControllerCreateDelegatedSigner2Errors[keyof WalletsV2025ControllerCreateDelegatedSigner2Errors];
type WalletsV2025ControllerCreateDelegatedSigner2Responses = {
    /**
     * The delegated signer has been successfully created.
     */
    201: DelegatedSignerV2025Dto;
};
type WalletsV2025ControllerCreateDelegatedSigner2Response = WalletsV2025ControllerCreateDelegatedSigner2Responses[keyof WalletsV2025ControllerCreateDelegatedSigner2Responses];
type WalletsV2025ControllerSubmitSignatureApprovals2Data = {
    body: SubmitApprovalV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals';
};
type WalletsV2025ControllerSubmitSignatureApprovals2Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerSubmitSignatureApprovals2Error = WalletsV2025ControllerSubmitSignatureApprovals2Errors[keyof WalletsV2025ControllerSubmitSignatureApprovals2Errors];
type WalletsV2025ControllerSubmitSignatureApprovals2Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsSignatureV2025ResponseDto;
};
type WalletsV2025ControllerSubmitSignatureApprovals2Response = WalletsV2025ControllerSubmitSignatureApprovals2Responses[keyof WalletsV2025ControllerSubmitSignatureApprovals2Responses];
type WalletsV2025ControllerGetSignature2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}';
};
type WalletsV2025ControllerGetSignature2Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetSignature2Error = WalletsV2025ControllerGetSignature2Errors[keyof WalletsV2025ControllerGetSignature2Errors];
type WalletsV2025ControllerGetSignature2Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsSignatureV2025ResponseDto;
};
type WalletsV2025ControllerGetSignature2Response = WalletsV2025ControllerGetSignature2Responses[keyof WalletsV2025ControllerGetSignature2Responses];
type WalletsV2025ControllerGetAllSignatures2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2025-06-09/wallets/{walletLocator}/signatures';
};
type WalletsV2025ControllerGetAllSignatures2Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetAllSignatures2Error = WalletsV2025ControllerGetAllSignatures2Errors[keyof WalletsV2025ControllerGetAllSignatures2Errors];
type WalletsV2025ControllerGetAllSignatures2Responses = {
    /**
     * The signatures have been successfully retrieved.
     */
    200: WalletsMultipleSignatureV2025ResponseDto;
};
type WalletsV2025ControllerGetAllSignatures2Response = WalletsV2025ControllerGetAllSignatures2Responses[keyof WalletsV2025ControllerGetAllSignatures2Responses];
type WalletsV2025ControllerCreateSignatureRequest2Data = {
    body: CreateSignatureV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}/signatures';
};
type WalletsV2025ControllerCreateSignatureRequest2Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerCreateSignatureRequest2Error = WalletsV2025ControllerCreateSignatureRequest2Errors[keyof WalletsV2025ControllerCreateSignatureRequest2Errors];
type WalletsV2025ControllerCreateSignatureRequest2Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsSignatureV2025ResponseDto;
};
type WalletsV2025ControllerCreateSignatureRequest2Response = WalletsV2025ControllerCreateSignatureRequest2Responses[keyof WalletsV2025ControllerCreateSignatureRequest2Responses];
type BalanceV20250609ControllerGetBalanceForLocator2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain(s) to query. Comma-separated list of chains
         */
        chains?: string;
        /**
         * The tokens to query. Comma-separated list of either tokens or token locator strings
         */
        tokens: string;
    };
    url: '/2025-06-09/wallets/{walletLocator}/balances';
};
type BalanceV20250609ControllerGetBalanceForLocator2Errors = {
    /**
     * Returns an error (400) if the wallet locator is invalid or if the address type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
};
type BalanceV20250609ControllerGetBalanceForLocator2Error = BalanceV20250609ControllerGetBalanceForLocator2Errors[keyof BalanceV20250609ControllerGetBalanceForLocator2Errors];
type BalanceV20250609ControllerGetBalanceForLocator2Responses = {
    /**
     * Returns the balance of the wallet for the given chain and currency
     */
    200: WalletBalanceV20250609ResponseDto;
};
type BalanceV20250609ControllerGetBalanceForLocator2Response = BalanceV20250609ControllerGetBalanceForLocator2Responses[keyof BalanceV20250609ControllerGetBalanceForLocator2Responses];
type WalletsV2025ControllerGetWalletByLocator2Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<chainType>[:<walletType>]` (walletType defaults to 'smart')
         * - `userId:<userId>:<chainType>[:<walletType>]` (white label user example)
         * - `phoneNumber:<phoneNumber>:<chainType>[:<walletType>]`
         * - `twitter:<handle>:<chainType>[:<walletType>]`
         * - `x:<handle>:<chainType>[:<walletType>]`
         * - `me:<chainType>[:<walletType>]` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2025-06-09/wallets/{walletLocator}';
};
type WalletsV2025ControllerGetWalletByLocator2Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerGetWalletByLocator2Error = WalletsV2025ControllerGetWalletByLocator2Errors[keyof WalletsV2025ControllerGetWalletByLocator2Errors];
type WalletsV2025ControllerGetWalletByLocator2Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV2025ResponseDto;
};
type WalletsV2025ControllerGetWalletByLocator2Response = WalletsV2025ControllerGetWalletByLocator2Responses[keyof WalletsV2025ControllerGetWalletByLocator2Responses];
type WalletsV2025ControllerCreateWallet2Data = {
    body: CreateWalletV2025Dto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate wallet creation
         */
        'x-idempotency-key'?: string;
    };
    path?: never;
    query?: never;
    url: '/2025-06-09/wallets';
};
type WalletsV2025ControllerCreateWallet2Errors = {
    /**
     * Returns an error if a wallet with the specified creation seed and signer configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
};
type WalletsV2025ControllerCreateWallet2Error = WalletsV2025ControllerCreateWallet2Errors[keyof WalletsV2025ControllerCreateWallet2Errors];
type WalletsV2025ControllerCreateWallet2Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for the provided owner or idempotencyKey, or creates and returns a new wallet (201). The response includes the wallet details and whether it was newly created.
     */
    201: WalletV2025ResponseDto;
};
type WalletsV2025ControllerCreateWallet2Response = WalletsV2025ControllerCreateWallet2Responses[keyof WalletsV2025ControllerCreateWallet2Responses];
type WalletsV1ControllerSubmitMeApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals';
};
type WalletsV1ControllerSubmitMeApprovals4Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitMeApprovals4Error = WalletsV1ControllerSubmitMeApprovals4Errors[keyof WalletsV1ControllerSubmitMeApprovals4Errors];
type WalletsV1ControllerSubmitMeApprovals4Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerSubmitMeApprovals4Response = WalletsV1ControllerSubmitMeApprovals4Responses[keyof WalletsV1ControllerSubmitMeApprovals4Responses];
type WalletsV1ControllerGetMeTransaction4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/transactions/{transactionId}';
};
type WalletsV1ControllerGetMeTransaction4Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeTransaction4Error = WalletsV1ControllerGetMeTransaction4Errors[keyof WalletsV1ControllerGetMeTransaction4Errors];
type WalletsV1ControllerGetMeTransaction4Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerGetMeTransaction4Response = WalletsV1ControllerGetMeTransaction4Responses[keyof WalletsV1ControllerGetMeTransaction4Responses];
type WalletsV1ControllerGetMeTransactionsWithoutChain4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2022-06-09/wallets/me{walletType}/transactions';
};
type WalletsV1ControllerGetMeTransactionsWithoutChain4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeTransactionsWithoutChain4Error = WalletsV1ControllerGetMeTransactionsWithoutChain4Errors[keyof WalletsV1ControllerGetMeTransactionsWithoutChain4Errors];
type WalletsV1ControllerGetMeTransactionsWithoutChain4Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionsResponseDto;
};
type WalletsV1ControllerGetMeTransactionsWithoutChain4Response = WalletsV1ControllerGetMeTransactionsWithoutChain4Responses[keyof WalletsV1ControllerGetMeTransactionsWithoutChain4Responses];
type WalletsV1ControllerCreateMeTransaction4Data = {
    body: CreateTransactionDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        'x-idempotency-key': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/transactions';
};
type WalletsV1ControllerCreateMeTransaction4Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified type is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};
type WalletsV1ControllerCreateMeTransaction4Error = WalletsV1ControllerCreateMeTransaction4Errors[keyof WalletsV1ControllerCreateMeTransaction4Errors];
type WalletsV1ControllerCreateMeTransaction4Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerCreateMeTransaction4Response = WalletsV1ControllerCreateMeTransaction4Responses[keyof WalletsV1ControllerCreateMeTransaction4Responses];
type WalletsV1ControllerGetMeDelegatedSigner4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        /**
         * Signer Locator
         * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
         */
        signer: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signers/{signer}';
};
type WalletsV1ControllerGetMeDelegatedSigner4Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeDelegatedSigner4Error = WalletsV1ControllerGetMeDelegatedSigner4Errors[keyof WalletsV1ControllerGetMeDelegatedSigner4Errors];
type WalletsV1ControllerGetMeDelegatedSigner4Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerDto;
};
type WalletsV1ControllerGetMeDelegatedSigner4Response = WalletsV1ControllerGetMeDelegatedSigner4Responses[keyof WalletsV1ControllerGetMeDelegatedSigner4Responses];
type WalletsV1ControllerCreateMeDelegatedSigner4Data = {
    body: CreateSignerInputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signers';
};
type WalletsV1ControllerCreateMeDelegatedSigner4Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateMeDelegatedSigner4Error = WalletsV1ControllerCreateMeDelegatedSigner4Errors[keyof WalletsV1ControllerCreateMeDelegatedSigner4Errors];
type WalletsV1ControllerCreateMeDelegatedSigner4Responses = {
    /**
     * The delegated signer has been successfully added to the wallet.
     */
    201: DelegatedSignerDto;
};
type WalletsV1ControllerCreateMeDelegatedSigner4Response = WalletsV1ControllerCreateMeDelegatedSigner4Responses[keyof WalletsV1ControllerCreateMeDelegatedSigner4Responses];
type WalletsV1ControllerSubmitMeSignatureApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals';
};
type WalletsV1ControllerSubmitMeSignatureApprovals4Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitMeSignatureApprovals4Error = WalletsV1ControllerSubmitMeSignatureApprovals4Errors[keyof WalletsV1ControllerSubmitMeSignatureApprovals4Errors];
type WalletsV1ControllerSubmitMeSignatureApprovals4Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerSubmitMeSignatureApprovals4Response = WalletsV1ControllerSubmitMeSignatureApprovals4Responses[keyof WalletsV1ControllerSubmitMeSignatureApprovals4Responses];
type WalletsV1ControllerGetMeSignature4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signatures/{signatureId}';
};
type WalletsV1ControllerGetMeSignature4Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeSignature4Error = WalletsV1ControllerGetMeSignature4Errors[keyof WalletsV1ControllerGetMeSignature4Errors];
type WalletsV1ControllerGetMeSignature4Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerGetMeSignature4Response = WalletsV1ControllerGetMeSignature4Responses[keyof WalletsV1ControllerGetMeSignature4Responses];
type WalletsV1ControllerCreateMeSignatureRequest4Data = {
    body: CreateSignatureRequestDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}/signatures';
};
type WalletsV1ControllerCreateMeSignatureRequest4Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateMeSignatureRequest4Error = WalletsV1ControllerCreateMeSignatureRequest4Errors[keyof WalletsV1ControllerCreateMeSignatureRequest4Errors];
type WalletsV1ControllerCreateMeSignatureRequest4Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerCreateMeSignatureRequest4Response = WalletsV1ControllerCreateMeSignatureRequest4Responses[keyof WalletsV1ControllerCreateMeSignatureRequest4Responses];
type WalletsV1ControllerGetMeWalletActivity4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query: {
        /**
         * The blockchain network to query. Either an EVM chain, Solana, or Stellar.
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow' | 'solana' | 'stellar';
    };
    url: '/2022-06-09/wallets/me{walletType}/activity';
};
type WalletsV1ControllerGetMeWalletActivity4Errors = {
    /**
     * Returns an error if a wallet with the specified type not found for the authenticated user
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetMeWalletActivity4Error = WalletsV1ControllerGetMeWalletActivity4Errors[keyof WalletsV1ControllerGetMeWalletActivity4Errors];
type WalletsV1ControllerGetMeWalletActivity4Responses = {
    /**
     * The wallet activity has been successfully retrieved.
     */
    200: WalletsV1Alpha2ActivityResponseDto;
};
type WalletsV1ControllerGetMeWalletActivity4Response = WalletsV1ControllerGetMeWalletActivity4Responses[keyof WalletsV1ControllerGetMeWalletActivity4Responses];
type WalletsV1ControllerGetMeWallet4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        walletType: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/me{walletType}';
};
type WalletsV1ControllerGetMeWallet4Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerGetMeWallet4Response = WalletsV1ControllerGetMeWallet4Responses[keyof WalletsV1ControllerGetMeWallet4Responses];
type WalletsV1ControllerCreateMeWallet4Data = {
    body: CreateWalletDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path?: never;
    query?: never;
    url: '/2022-06-09/wallets/me';
};
type WalletsV1ControllerCreateMeWallet4Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for this user, or creates and returns a new wallet (201).
     */
    201: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerCreateMeWallet4Response = WalletsV1ControllerCreateMeWallet4Responses[keyof WalletsV1ControllerCreateMeWallet4Responses];
type WalletsV1ControllerSubmitApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals';
};
type WalletsV1ControllerSubmitApprovals4Errors = {
    /**
     * Returns an error if the signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the signature for signer was already submitted
     */
    409: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction already has the required number of approvals
     */
    422: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitApprovals4Error = WalletsV1ControllerSubmitApprovals4Errors[keyof WalletsV1ControllerSubmitApprovals4Errors];
type WalletsV1ControllerSubmitApprovals4Responses = {
    /**
     * The approval has successfully been submitted to the transaction.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerSubmitApprovals4Response = WalletsV1ControllerSubmitApprovals4Responses[keyof WalletsV1ControllerSubmitApprovals4Responses];
type WalletsV1ControllerGetTransaction4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        transactionId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}';
};
type WalletsV1ControllerGetTransaction4Errors = {
    /**
     * Returns an error if the wallet or transaction is not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetTransaction4Error = WalletsV1ControllerGetTransaction4Errors[keyof WalletsV1ControllerGetTransaction4Errors];
type WalletsV1ControllerGetTransaction4Responses = {
    /**
     * The transaction has been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerGetTransaction4Response = WalletsV1ControllerGetTransaction4Responses[keyof WalletsV1ControllerGetTransaction4Responses];
type WalletsV1ControllerGetTransactionsWithoutChain4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2022-06-09/wallets/{walletLocator}/transactions';
};
type WalletsV1ControllerGetTransactionsWithoutChain4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetTransactionsWithoutChain4Error = WalletsV1ControllerGetTransactionsWithoutChain4Errors[keyof WalletsV1ControllerGetTransactionsWithoutChain4Errors];
type WalletsV1ControllerGetTransactionsWithoutChain4Responses = {
    /**
     * The transactions have been successfully retrieved.
     */
    200: WalletsV1Alpha2TransactionsResponseDto;
};
type WalletsV1ControllerGetTransactionsWithoutChain4Response = WalletsV1ControllerGetTransactionsWithoutChain4Responses[keyof WalletsV1ControllerGetTransactionsWithoutChain4Responses];
type WalletsV1ControllerCreateTransaction4Data = {
    body: CreateTransactionDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate transaction creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/transactions';
};
type WalletsV1ControllerCreateTransaction4Errors = {
    /**
     * Returns an error if the transaction or the provided signer is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the transaction fails during simulation
     */
    422: WalletV1Alpha2TransactionErrorDto;
};
type WalletsV1ControllerCreateTransaction4Error = WalletsV1ControllerCreateTransaction4Errors[keyof WalletsV1ControllerCreateTransaction4Errors];
type WalletsV1ControllerCreateTransaction4Responses = {
    /**
     * The transaction has been successfully created.
     */
    201: WalletsV1Alpha2TransactionResponseDto;
};
type WalletsV1ControllerCreateTransaction4Response = WalletsV1ControllerCreateTransaction4Responses[keyof WalletsV1ControllerCreateTransaction4Responses];
type WalletsV1ControllerGetDelegatedSigner4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        /**
         * Signer Locator
         * A signer locator that can be either a of format '<signerAddress>' for keypair type signers or '<signerType>:<signerIdentifier>'
         */
        signer: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signers/{signer}';
};
type WalletsV1ControllerGetDelegatedSigner4Errors = {
    /**
     * Returns an error if the wallet or signer not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetDelegatedSigner4Error = WalletsV1ControllerGetDelegatedSigner4Errors[keyof WalletsV1ControllerGetDelegatedSigner4Errors];
type WalletsV1ControllerGetDelegatedSigner4Responses = {
    /**
     * The delegated signer has been successfully retrieved.
     */
    200: DelegatedSignerDto;
};
type WalletsV1ControllerGetDelegatedSigner4Response = WalletsV1ControllerGetDelegatedSigner4Responses[keyof WalletsV1ControllerGetDelegatedSigner4Responses];
type WalletsV1ControllerCreateDelegatedSigner4Data = {
    body: CreateSignerInputDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signers';
};
type WalletsV1ControllerCreateDelegatedSigner4Errors = {
    /**
     * Returns an error if a delegated signer with specified configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateDelegatedSigner4Error = WalletsV1ControllerCreateDelegatedSigner4Errors[keyof WalletsV1ControllerCreateDelegatedSigner4Errors];
type WalletsV1ControllerCreateDelegatedSigner4Responses = {
    /**
     * The delegated signer has been successfully added to the wallet.
     */
    201: DelegatedSignerDto;
};
type WalletsV1ControllerCreateDelegatedSigner4Response = WalletsV1ControllerCreateDelegatedSigner4Responses[keyof WalletsV1ControllerCreateDelegatedSigner4Responses];
type WalletsV1ControllerSubmitSignatureApprovals4Data = {
    body: SubmitApprovalDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals';
};
type WalletsV1ControllerSubmitSignatureApprovals4Errors = {
    /**
     * Returns an error if the signature is not valid
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerSubmitSignatureApprovals4Error = WalletsV1ControllerSubmitSignatureApprovals4Errors[keyof WalletsV1ControllerSubmitSignatureApprovals4Errors];
type WalletsV1ControllerSubmitSignatureApprovals4Responses = {
    /**
     * The signature has been successfully approved.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerSubmitSignatureApprovals4Response = WalletsV1ControllerSubmitSignatureApprovals4Responses[keyof WalletsV1ControllerSubmitSignatureApprovals4Responses];
type WalletsV1ControllerGetSignature4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
        signatureId: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}';
};
type WalletsV1ControllerGetSignature4Errors = {
    /**
     * Returns an error if the wallet or signature not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetSignature4Error = WalletsV1ControllerGetSignature4Errors[keyof WalletsV1ControllerGetSignature4Errors];
type WalletsV1ControllerGetSignature4Responses = {
    /**
     * The signature has been successfully retrieved.
     */
    200: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerGetSignature4Response = WalletsV1ControllerGetSignature4Responses[keyof WalletsV1ControllerGetSignature4Responses];
type WalletsV1ControllerGetAllSignatures4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
    };
    url: '/2022-06-09/wallets/{walletLocator}/signatures';
};
type WalletsV1ControllerGetAllSignatures4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetAllSignatures4Error = WalletsV1ControllerGetAllSignatures4Errors[keyof WalletsV1ControllerGetAllSignatures4Errors];
type WalletsV1ControllerGetAllSignatures4Responses = {
    /**
     * The signatures have been successfully retrieved.
     */
    200: WalletsV1Alpha2MultipleSignatureResponseDto;
};
type WalletsV1ControllerGetAllSignatures4Response = WalletsV1ControllerGetAllSignatures4Responses[keyof WalletsV1ControllerGetAllSignatures4Responses];
type WalletsV1ControllerCreateSignatureRequest4Data = {
    body: CreateSignatureRequestDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate signature creation
         */
        'x-idempotency-key'?: string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}/signatures';
};
type WalletsV1ControllerCreateSignatureRequest4Errors = {
    /**
     * Returns an error if the signature type is not supported
     */
    400: WalletV1Alpha2ErrorDto;
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateSignatureRequest4Error = WalletsV1ControllerCreateSignatureRequest4Errors[keyof WalletsV1ControllerCreateSignatureRequest4Errors];
type WalletsV1ControllerCreateSignatureRequest4Responses = {
    /**
     * The signature has been successfully created.
     */
    201: WalletsV1Alpha2SignatureResponseDto;
};
type WalletsV1ControllerCreateSignatureRequest4Response = WalletsV1ControllerCreateSignatureRequest4Responses[keyof WalletsV1ControllerCreateSignatureRequest4Responses];
type WalletsV1ControllerGetWalletActivity4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query: {
        /**
         * The blockchain network to query. Either an EVM chain, Solana, or Stellar.
         */
        chain: 'arbitrum-sepolia' | 'avalanche-fuji' | 'curtis' | 'barret-testnet' | 'base-goerli' | 'base-sepolia' | 'bsc-testnet' | 'chiliz-spicy-testnet' | 'coti-testnet' | 'ethereum-goerli' | 'ethereum-sepolia' | 'hedera-testnet' | 'hypersonic-testnet' | 'lightlink-pegasus' | 'mantle-sepolia' | 'optimism-goerli' | 'optimism-sepolia' | 'polygon-amoy' | 'polygon-mumbai' | 'crossmint-private-testnet-ethereum' | 'crossmint-private-testnet-polygon' | 'rari-testnet' | 'scroll-sepolia' | 'sei-atlantic-2-testnet' | 'shape-sepolia' | 'skale-nebula-testnet' | 'soneium-minato-testnet' | 'space-testnet' | 'story-testnet' | 'verify-testnet' | 'viction-testnet' | 'xai-sepolia-testnet' | 'zkatana' | 'zkyoto' | 'zora-goerli' | 'zora-sepolia' | 'mode-sepolia' | 'u2u-nebulas' | 'zenchain-testnet' | 'abstract-testnet' | 'world-chain-sepolia' | 'flow-testnet' | 'ethereum' | 'polygon' | 'bsc' | 'optimism' | 'arbitrum' | 'base' | 'zora' | 'arbitrumnova' | 'astar-zkevm' | 'apechain' | 'apex' | 'boss' | 'hedera' | 'coti' | 'lightlink' | 'mantle' | 'skale-nebula' | 'sei-pacific-1' | 'chiliz' | 'avalanche' | 'xai' | 'shape' | 'rari' | 'scroll' | 'viction' | 'mode' | 'space' | 'soneium' | 'story' | 'u2u-solaris' | 'abstract' | 'world-chain' | 'flow' | 'solana' | 'stellar';
    };
    url: '/2022-06-09/wallets/{walletLocator}/activity';
};
type WalletsV1ControllerGetWalletActivity4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetWalletActivity4Error = WalletsV1ControllerGetWalletActivity4Errors[keyof WalletsV1ControllerGetWalletActivity4Errors];
type WalletsV1ControllerGetWalletActivity4Responses = {
    /**
     * The wallet activity has been successfully retrieved.
     */
    200: WalletsV1Alpha2ActivityResponseDto;
};
type WalletsV1ControllerGetWalletActivity4Response = WalletsV1ControllerGetWalletActivity4Responses[keyof WalletsV1ControllerGetWalletActivity4Responses];
type WalletsV1ControllerGetWalletByLocator4Data = {
    body?: never;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
    };
    path: {
        /**
         * A wallet locator can be of the format:
         * - `<walletAddress>`
         * - `email:<email>:<walletType>`
         * - `userId:<userId>:<walletType>`
         * - `userId:<userId>:<walletType>` (white label user example)
         * - `phoneNumber:<phoneNumber>:<walletType>`
         * - `twitter:<handle>:<walletType>`
         * - `x:<handle>:<walletType>`
         * - `me:<walletType>` (Use when calling from the client side with a client API key)
         */
        walletLocator: string;
    };
    query?: never;
    url: '/2022-06-09/wallets/{walletLocator}';
};
type WalletsV1ControllerGetWalletByLocator4Errors = {
    /**
     * Returns an error if a wallet with the specified locator not found
     */
    404: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerGetWalletByLocator4Error = WalletsV1ControllerGetWalletByLocator4Errors[keyof WalletsV1ControllerGetWalletByLocator4Errors];
type WalletsV1ControllerGetWalletByLocator4Responses = {
    /**
     * The record has been successfully retreived.
     */
    200: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerGetWalletByLocator4Response = WalletsV1ControllerGetWalletByLocator4Responses[keyof WalletsV1ControllerGetWalletByLocator4Responses];
type WalletNftControllerGetNftsFromWallet4Data = {
    body?: never;
    path: {
        locator: string;
    };
    query?: {
        page?: string;
        perPage?: string;
        /**
         * Filter NFTs by contract address. Can be a single address or an array of addresses.
         */
        contractAddress?: Array<unknown>;
        /**
         * Filter NFTs by token ID
         */
        tokenId?: string;
    };
    url: '/2022-06-09/wallets/{locator}/nfts';
};
type WalletNftControllerGetNftsFromWallet4Responses = {
    /**
     * Returns an array of NFTs in the wallet
     */
    200: WalletNftsResponseDto;
};
type WalletNftControllerGetNftsFromWallet4Response = WalletNftControllerGetNftsFromWallet4Responses[keyof WalletNftControllerGetNftsFromWallet4Responses];
type WalletsV1ControllerCreateWallet4Data = {
    body: CreateWalletDto;
    headers: {
        /**
         * API key required for authentication
         */
        'X-API-KEY': string;
        /**
         * Unique key to prevent duplicate wallet creation
         */
        'x-idempotency-key'?: string;
    };
    path?: never;
    query?: never;
    url: '/2022-06-09/wallets';
};
type WalletsV1ControllerCreateWallet4Errors = {
    /**
     * Returns an error if a wallet with the specified creation seed and signer configuration already exists
     */
    400: WalletV1Alpha2ErrorDto;
};
type WalletsV1ControllerCreateWallet4Error = WalletsV1ControllerCreateWallet4Errors[keyof WalletsV1ControllerCreateWallet4Errors];
type WalletsV1ControllerCreateWallet4Responses = {
    /**
     * Returns an existing wallet (200) if one already exists for the provided linkedUser or idempotencyKey, or creates and returns a new wallet (201). The response includes the wallet details and whether it was newly created.
     */
    201: WalletV1Alpha2ResponseDto;
};
type WalletsV1ControllerCreateWallet4Response = WalletsV1ControllerCreateWallet4Responses[keyof WalletsV1ControllerCreateWallet4Responses];
type ClientOptions = {
    baseUrl: 'https://staging.crossmint.com/api' | 'https://www.crossmint.com/api' | (string & {});
};

export type { BalanceControllerFundWallet2Data, BalanceControllerFundWallet2Error, BalanceControllerFundWallet2Errors, BalanceControllerFundWallet2Response, BalanceControllerFundWallet2Responses, BalanceControllerGetBalanceForLocator2Data, BalanceControllerGetBalanceForLocator2Error, BalanceControllerGetBalanceForLocator2Errors, BalanceControllerGetBalanceForLocator2Response, BalanceControllerGetBalanceForLocator2Responses, BalanceUnstableControllerGetBalanceForLocator2Data, BalanceUnstableControllerGetBalanceForLocator2Error, BalanceUnstableControllerGetBalanceForLocator2Errors, BalanceUnstableControllerGetBalanceForLocator2Response, BalanceUnstableControllerGetBalanceForLocator2Responses, BalanceV20250609ControllerGetBalanceForLocator2Data, BalanceV20250609ControllerGetBalanceForLocator2Error, BalanceV20250609ControllerGetBalanceForLocator2Errors, BalanceV20250609ControllerGetBalanceForLocator2Response, BalanceV20250609ControllerGetBalanceForLocator2Responses, ClientOptions, CreateSignatureRequestDto, CreateSignatureV2025Dto, CreateSignerInputDto, CreateSignerV2025InputDto, CreateTransactionDto, CreateTransactionV2025Dto, CreateWalletDto, CreateWalletV2025Dto, DelegatedSignerDto, DelegatedSignerV2025Dto, FundWalletAmountDto, SchemaHolderClass, SendOrDepositTokenV2025Dto, SendTokenDto, SendTokenV2025Dto, SubmitApprovalDto, SubmitApprovalV2025Dto, WalletActivityUnstableControllerGetMeWalletActivity2Data, WalletActivityUnstableControllerGetMeWalletActivity2Error, WalletActivityUnstableControllerGetMeWalletActivity2Errors, WalletActivityUnstableControllerGetMeWalletActivity2Response, WalletActivityUnstableControllerGetMeWalletActivity2Responses, WalletActivityUnstableControllerGetWalletActivity2Data, WalletActivityUnstableControllerGetWalletActivity2Error, WalletActivityUnstableControllerGetWalletActivity2Errors, WalletActivityUnstableControllerGetWalletActivity2Response, WalletActivityUnstableControllerGetWalletActivity2Responses, WalletBalanceResponseDto, WalletBalanceUnstableResponseDto, WalletBalanceV20250609ResponseDto, WalletNftControllerGetNftsFromWallet4Data, WalletNftControllerGetNftsFromWallet4Response, WalletNftControllerGetNftsFromWallet4Responses, WalletNftsResponseDto, WalletV1Alpha2ErrorDto, WalletV1Alpha2ResponseDto, WalletV1Alpha2TransactionErrorDto, WalletV2025ResponseDto, WalletsActivityResponseUnstableDto, WalletsMultipleSignatureV2025ResponseDto, WalletsMultipleTransactionV2025ResponseDto, WalletsSendTokenControllerSendMeToken2Data, WalletsSendTokenControllerSendMeToken2Response, WalletsSendTokenControllerSendMeToken2Responses, WalletsSendTokenControllerSendToken2Data, WalletsSendTokenControllerSendToken2Response, WalletsSendTokenControllerSendToken2Responses, WalletsSendTokenV2025ControllerCreatePayout2Data, WalletsSendTokenV2025ControllerCreatePayout2Response, WalletsSendTokenV2025ControllerCreatePayout2Responses, WalletsSendTokenV2025ControllerSendMeToken2Data, WalletsSendTokenV2025ControllerSendMeToken2Response, WalletsSendTokenV2025ControllerSendMeToken2Responses, WalletsSendTokenV2025ControllerSendToken2Data, WalletsSendTokenV2025ControllerSendToken2Response, WalletsSendTokenV2025ControllerSendToken2Responses, WalletsSignatureV2025ResponseDto, WalletsTransactionV2025ResponseDto, WalletsV1Alpha2ActivityResponseDto, WalletsV1Alpha2MultipleSignatureResponseDto, WalletsV1Alpha2SignatureResponseDto, WalletsV1Alpha2TransactionResponseDto, WalletsV1Alpha2TransactionResponseWithSendParamsDto, WalletsV1Alpha2TransactionsResponseDto, WalletsV1ControllerCreateDelegatedSigner4Data, WalletsV1ControllerCreateDelegatedSigner4Error, WalletsV1ControllerCreateDelegatedSigner4Errors, WalletsV1ControllerCreateDelegatedSigner4Response, WalletsV1ControllerCreateDelegatedSigner4Responses, WalletsV1ControllerCreateDelegatedSigner5Data, WalletsV1ControllerCreateDelegatedSigner5Error, WalletsV1ControllerCreateDelegatedSigner5Errors, WalletsV1ControllerCreateDelegatedSigner5Response, WalletsV1ControllerCreateDelegatedSigner5Responses, WalletsV1ControllerCreateMeDelegatedSigner4Data, WalletsV1ControllerCreateMeDelegatedSigner4Error, WalletsV1ControllerCreateMeDelegatedSigner4Errors, WalletsV1ControllerCreateMeDelegatedSigner4Response, WalletsV1ControllerCreateMeDelegatedSigner4Responses, WalletsV1ControllerCreateMeDelegatedSigner5Data, WalletsV1ControllerCreateMeDelegatedSigner5Error, WalletsV1ControllerCreateMeDelegatedSigner5Errors, WalletsV1ControllerCreateMeDelegatedSigner5Response, WalletsV1ControllerCreateMeDelegatedSigner5Responses, WalletsV1ControllerCreateMeSignatureRequest4Data, WalletsV1ControllerCreateMeSignatureRequest4Error, WalletsV1ControllerCreateMeSignatureRequest4Errors, WalletsV1ControllerCreateMeSignatureRequest4Response, WalletsV1ControllerCreateMeSignatureRequest4Responses, WalletsV1ControllerCreateMeSignatureRequest5Data, WalletsV1ControllerCreateMeSignatureRequest5Error, WalletsV1ControllerCreateMeSignatureRequest5Errors, WalletsV1ControllerCreateMeSignatureRequest5Response, WalletsV1ControllerCreateMeSignatureRequest5Responses, WalletsV1ControllerCreateMeTransaction4Data, WalletsV1ControllerCreateMeTransaction4Error, WalletsV1ControllerCreateMeTransaction4Errors, WalletsV1ControllerCreateMeTransaction4Response, WalletsV1ControllerCreateMeTransaction4Responses, WalletsV1ControllerCreateMeTransaction5Data, WalletsV1ControllerCreateMeTransaction5Error, WalletsV1ControllerCreateMeTransaction5Errors, WalletsV1ControllerCreateMeTransaction5Response, WalletsV1ControllerCreateMeTransaction5Responses, WalletsV1ControllerCreateMeWallet4Data, WalletsV1ControllerCreateMeWallet4Response, WalletsV1ControllerCreateMeWallet4Responses, WalletsV1ControllerCreateMeWallet5Data, WalletsV1ControllerCreateMeWallet5Response, WalletsV1ControllerCreateMeWallet5Responses, WalletsV1ControllerCreateSignatureRequest4Data, WalletsV1ControllerCreateSignatureRequest4Error, WalletsV1ControllerCreateSignatureRequest4Errors, WalletsV1ControllerCreateSignatureRequest4Response, WalletsV1ControllerCreateSignatureRequest4Responses, WalletsV1ControllerCreateSignatureRequest5Data, WalletsV1ControllerCreateSignatureRequest5Error, WalletsV1ControllerCreateSignatureRequest5Errors, WalletsV1ControllerCreateSignatureRequest5Response, WalletsV1ControllerCreateSignatureRequest5Responses, WalletsV1ControllerCreateTransaction4Data, WalletsV1ControllerCreateTransaction4Error, WalletsV1ControllerCreateTransaction4Errors, WalletsV1ControllerCreateTransaction4Response, WalletsV1ControllerCreateTransaction4Responses, WalletsV1ControllerCreateTransaction5Data, WalletsV1ControllerCreateTransaction5Error, WalletsV1ControllerCreateTransaction5Errors, WalletsV1ControllerCreateTransaction5Response, WalletsV1ControllerCreateTransaction5Responses, WalletsV1ControllerCreateWallet4Data, WalletsV1ControllerCreateWallet4Error, WalletsV1ControllerCreateWallet4Errors, WalletsV1ControllerCreateWallet4Response, WalletsV1ControllerCreateWallet4Responses, WalletsV1ControllerCreateWallet5Data, WalletsV1ControllerCreateWallet5Error, WalletsV1ControllerCreateWallet5Errors, WalletsV1ControllerCreateWallet5Response, WalletsV1ControllerCreateWallet5Responses, WalletsV1ControllerGetAllSignatures4Data, WalletsV1ControllerGetAllSignatures4Error, WalletsV1ControllerGetAllSignatures4Errors, WalletsV1ControllerGetAllSignatures4Response, WalletsV1ControllerGetAllSignatures4Responses, WalletsV1ControllerGetAllSignatures5Data, WalletsV1ControllerGetAllSignatures5Error, WalletsV1ControllerGetAllSignatures5Errors, WalletsV1ControllerGetAllSignatures5Response, WalletsV1ControllerGetAllSignatures5Responses, WalletsV1ControllerGetDelegatedSigner4Data, WalletsV1ControllerGetDelegatedSigner4Error, WalletsV1ControllerGetDelegatedSigner4Errors, WalletsV1ControllerGetDelegatedSigner4Response, WalletsV1ControllerGetDelegatedSigner4Responses, WalletsV1ControllerGetDelegatedSigner5Data, WalletsV1ControllerGetDelegatedSigner5Error, WalletsV1ControllerGetDelegatedSigner5Errors, WalletsV1ControllerGetDelegatedSigner5Response, WalletsV1ControllerGetDelegatedSigner5Responses, WalletsV1ControllerGetMeDelegatedSigner4Data, WalletsV1ControllerGetMeDelegatedSigner4Error, WalletsV1ControllerGetMeDelegatedSigner4Errors, WalletsV1ControllerGetMeDelegatedSigner4Response, WalletsV1ControllerGetMeDelegatedSigner4Responses, WalletsV1ControllerGetMeDelegatedSigner5Data, WalletsV1ControllerGetMeDelegatedSigner5Error, WalletsV1ControllerGetMeDelegatedSigner5Errors, WalletsV1ControllerGetMeDelegatedSigner5Response, WalletsV1ControllerGetMeDelegatedSigner5Responses, WalletsV1ControllerGetMeSignature4Data, WalletsV1ControllerGetMeSignature4Error, WalletsV1ControllerGetMeSignature4Errors, WalletsV1ControllerGetMeSignature4Response, WalletsV1ControllerGetMeSignature4Responses, WalletsV1ControllerGetMeSignature5Data, WalletsV1ControllerGetMeSignature5Error, WalletsV1ControllerGetMeSignature5Errors, WalletsV1ControllerGetMeSignature5Response, WalletsV1ControllerGetMeSignature5Responses, WalletsV1ControllerGetMeTransaction4Data, WalletsV1ControllerGetMeTransaction4Error, WalletsV1ControllerGetMeTransaction4Errors, WalletsV1ControllerGetMeTransaction4Response, WalletsV1ControllerGetMeTransaction4Responses, WalletsV1ControllerGetMeTransaction5Data, WalletsV1ControllerGetMeTransaction5Error, WalletsV1ControllerGetMeTransaction5Errors, WalletsV1ControllerGetMeTransaction5Response, WalletsV1ControllerGetMeTransaction5Responses, WalletsV1ControllerGetMeTransactionsWithoutChain4Data, WalletsV1ControllerGetMeTransactionsWithoutChain4Error, WalletsV1ControllerGetMeTransactionsWithoutChain4Errors, WalletsV1ControllerGetMeTransactionsWithoutChain4Response, WalletsV1ControllerGetMeTransactionsWithoutChain4Responses, WalletsV1ControllerGetMeTransactionsWithoutChain5Data, WalletsV1ControllerGetMeTransactionsWithoutChain5Error, WalletsV1ControllerGetMeTransactionsWithoutChain5Errors, WalletsV1ControllerGetMeTransactionsWithoutChain5Response, WalletsV1ControllerGetMeTransactionsWithoutChain5Responses, WalletsV1ControllerGetMeWallet4Data, WalletsV1ControllerGetMeWallet4Response, WalletsV1ControllerGetMeWallet4Responses, WalletsV1ControllerGetMeWallet5Data, WalletsV1ControllerGetMeWallet5Response, WalletsV1ControllerGetMeWallet5Responses, WalletsV1ControllerGetMeWalletActivity4Data, WalletsV1ControllerGetMeWalletActivity4Error, WalletsV1ControllerGetMeWalletActivity4Errors, WalletsV1ControllerGetMeWalletActivity4Response, WalletsV1ControllerGetMeWalletActivity4Responses, WalletsV1ControllerGetMeWalletActivity5Data, WalletsV1ControllerGetMeWalletActivity5Error, WalletsV1ControllerGetMeWalletActivity5Errors, WalletsV1ControllerGetMeWalletActivity5Response, WalletsV1ControllerGetMeWalletActivity5Responses, WalletsV1ControllerGetSignature4Data, WalletsV1ControllerGetSignature4Error, WalletsV1ControllerGetSignature4Errors, WalletsV1ControllerGetSignature4Response, WalletsV1ControllerGetSignature4Responses, WalletsV1ControllerGetSignature5Data, WalletsV1ControllerGetSignature5Error, WalletsV1ControllerGetSignature5Errors, WalletsV1ControllerGetSignature5Response, WalletsV1ControllerGetSignature5Responses, WalletsV1ControllerGetTransaction4Data, WalletsV1ControllerGetTransaction4Error, WalletsV1ControllerGetTransaction4Errors, WalletsV1ControllerGetTransaction4Response, WalletsV1ControllerGetTransaction4Responses, WalletsV1ControllerGetTransaction5Data, WalletsV1ControllerGetTransaction5Error, WalletsV1ControllerGetTransaction5Errors, WalletsV1ControllerGetTransaction5Response, WalletsV1ControllerGetTransaction5Responses, WalletsV1ControllerGetTransactionsWithoutChain4Data, WalletsV1ControllerGetTransactionsWithoutChain4Error, WalletsV1ControllerGetTransactionsWithoutChain4Errors, WalletsV1ControllerGetTransactionsWithoutChain4Response, WalletsV1ControllerGetTransactionsWithoutChain4Responses, WalletsV1ControllerGetTransactionsWithoutChain5Data, WalletsV1ControllerGetTransactionsWithoutChain5Error, WalletsV1ControllerGetTransactionsWithoutChain5Errors, WalletsV1ControllerGetTransactionsWithoutChain5Response, WalletsV1ControllerGetTransactionsWithoutChain5Responses, WalletsV1ControllerGetWalletActivity4Data, WalletsV1ControllerGetWalletActivity4Error, WalletsV1ControllerGetWalletActivity4Errors, WalletsV1ControllerGetWalletActivity4Response, WalletsV1ControllerGetWalletActivity4Responses, WalletsV1ControllerGetWalletActivity5Data, WalletsV1ControllerGetWalletActivity5Error, WalletsV1ControllerGetWalletActivity5Errors, WalletsV1ControllerGetWalletActivity5Response, WalletsV1ControllerGetWalletActivity5Responses, WalletsV1ControllerGetWalletByLocator4Data, WalletsV1ControllerGetWalletByLocator4Error, WalletsV1ControllerGetWalletByLocator4Errors, WalletsV1ControllerGetWalletByLocator4Response, WalletsV1ControllerGetWalletByLocator4Responses, WalletsV1ControllerGetWalletByLocator5Data, WalletsV1ControllerGetWalletByLocator5Error, WalletsV1ControllerGetWalletByLocator5Errors, WalletsV1ControllerGetWalletByLocator5Response, WalletsV1ControllerGetWalletByLocator5Responses, WalletsV1ControllerSubmitApprovals4Data, WalletsV1ControllerSubmitApprovals4Error, WalletsV1ControllerSubmitApprovals4Errors, WalletsV1ControllerSubmitApprovals4Response, WalletsV1ControllerSubmitApprovals4Responses, WalletsV1ControllerSubmitApprovals5Data, WalletsV1ControllerSubmitApprovals5Error, WalletsV1ControllerSubmitApprovals5Errors, WalletsV1ControllerSubmitApprovals5Response, WalletsV1ControllerSubmitApprovals5Responses, WalletsV1ControllerSubmitMeApprovals4Data, WalletsV1ControllerSubmitMeApprovals4Error, WalletsV1ControllerSubmitMeApprovals4Errors, WalletsV1ControllerSubmitMeApprovals4Response, WalletsV1ControllerSubmitMeApprovals4Responses, WalletsV1ControllerSubmitMeApprovals5Data, WalletsV1ControllerSubmitMeApprovals5Error, WalletsV1ControllerSubmitMeApprovals5Errors, WalletsV1ControllerSubmitMeApprovals5Response, WalletsV1ControllerSubmitMeApprovals5Responses, WalletsV1ControllerSubmitMeSignatureApprovals4Data, WalletsV1ControllerSubmitMeSignatureApprovals4Error, WalletsV1ControllerSubmitMeSignatureApprovals4Errors, WalletsV1ControllerSubmitMeSignatureApprovals4Response, WalletsV1ControllerSubmitMeSignatureApprovals4Responses, WalletsV1ControllerSubmitMeSignatureApprovals5Data, WalletsV1ControllerSubmitMeSignatureApprovals5Error, WalletsV1ControllerSubmitMeSignatureApprovals5Errors, WalletsV1ControllerSubmitMeSignatureApprovals5Response, WalletsV1ControllerSubmitMeSignatureApprovals5Responses, WalletsV1ControllerSubmitSignatureApprovals4Data, WalletsV1ControllerSubmitSignatureApprovals4Error, WalletsV1ControllerSubmitSignatureApprovals4Errors, WalletsV1ControllerSubmitSignatureApprovals4Response, WalletsV1ControllerSubmitSignatureApprovals4Responses, WalletsV1ControllerSubmitSignatureApprovals5Data, WalletsV1ControllerSubmitSignatureApprovals5Error, WalletsV1ControllerSubmitSignatureApprovals5Errors, WalletsV1ControllerSubmitSignatureApprovals5Response, WalletsV1ControllerSubmitSignatureApprovals5Responses, WalletsV2025ControllerCreateDelegatedSigner2Data, WalletsV2025ControllerCreateDelegatedSigner2Error, WalletsV2025ControllerCreateDelegatedSigner2Errors, WalletsV2025ControllerCreateDelegatedSigner2Response, WalletsV2025ControllerCreateDelegatedSigner2Responses, WalletsV2025ControllerCreateMeDelegatedSigner2Data, WalletsV2025ControllerCreateMeDelegatedSigner2Error, WalletsV2025ControllerCreateMeDelegatedSigner2Errors, WalletsV2025ControllerCreateMeDelegatedSigner2Response, WalletsV2025ControllerCreateMeDelegatedSigner2Responses, WalletsV2025ControllerCreateMeSignatureRequest2Data, WalletsV2025ControllerCreateMeSignatureRequest2Error, WalletsV2025ControllerCreateMeSignatureRequest2Errors, WalletsV2025ControllerCreateMeSignatureRequest2Response, WalletsV2025ControllerCreateMeSignatureRequest2Responses, WalletsV2025ControllerCreateMeTransaction2Data, WalletsV2025ControllerCreateMeTransaction2Error, WalletsV2025ControllerCreateMeTransaction2Errors, WalletsV2025ControllerCreateMeTransaction2Response, WalletsV2025ControllerCreateMeTransaction2Responses, WalletsV2025ControllerCreateMeWallet2Data, WalletsV2025ControllerCreateMeWallet2Response, WalletsV2025ControllerCreateMeWallet2Responses, WalletsV2025ControllerCreateSignatureRequest2Data, WalletsV2025ControllerCreateSignatureRequest2Error, WalletsV2025ControllerCreateSignatureRequest2Errors, WalletsV2025ControllerCreateSignatureRequest2Response, WalletsV2025ControllerCreateSignatureRequest2Responses, WalletsV2025ControllerCreateTransaction2Data, WalletsV2025ControllerCreateTransaction2Error, WalletsV2025ControllerCreateTransaction2Errors, WalletsV2025ControllerCreateTransaction2Response, WalletsV2025ControllerCreateTransaction2Responses, WalletsV2025ControllerCreateWallet2Data, WalletsV2025ControllerCreateWallet2Error, WalletsV2025ControllerCreateWallet2Errors, WalletsV2025ControllerCreateWallet2Response, WalletsV2025ControllerCreateWallet2Responses, WalletsV2025ControllerGetAllSignatures2Data, WalletsV2025ControllerGetAllSignatures2Error, WalletsV2025ControllerGetAllSignatures2Errors, WalletsV2025ControllerGetAllSignatures2Response, WalletsV2025ControllerGetAllSignatures2Responses, WalletsV2025ControllerGetDelegatedSigner2Data, WalletsV2025ControllerGetDelegatedSigner2Error, WalletsV2025ControllerGetDelegatedSigner2Errors, WalletsV2025ControllerGetDelegatedSigner2Response, WalletsV2025ControllerGetDelegatedSigner2Responses, WalletsV2025ControllerGetMeDelegatedSigner2Data, WalletsV2025ControllerGetMeDelegatedSigner2Error, WalletsV2025ControllerGetMeDelegatedSigner2Errors, WalletsV2025ControllerGetMeDelegatedSigner2Response, WalletsV2025ControllerGetMeDelegatedSigner2Responses, WalletsV2025ControllerGetMeSignature2Data, WalletsV2025ControllerGetMeSignature2Error, WalletsV2025ControllerGetMeSignature2Errors, WalletsV2025ControllerGetMeSignature2Response, WalletsV2025ControllerGetMeSignature2Responses, WalletsV2025ControllerGetMeSignatures2Data, WalletsV2025ControllerGetMeSignatures2Error, WalletsV2025ControllerGetMeSignatures2Errors, WalletsV2025ControllerGetMeSignatures2Response, WalletsV2025ControllerGetMeSignatures2Responses, WalletsV2025ControllerGetMeTransaction2Data, WalletsV2025ControllerGetMeTransaction2Error, WalletsV2025ControllerGetMeTransaction2Errors, WalletsV2025ControllerGetMeTransaction2Response, WalletsV2025ControllerGetMeTransaction2Responses, WalletsV2025ControllerGetMeTransactionsWithoutChain2Data, WalletsV2025ControllerGetMeTransactionsWithoutChain2Error, WalletsV2025ControllerGetMeTransactionsWithoutChain2Errors, WalletsV2025ControllerGetMeTransactionsWithoutChain2Response, WalletsV2025ControllerGetMeTransactionsWithoutChain2Responses, WalletsV2025ControllerGetMeWallet2Data, WalletsV2025ControllerGetMeWallet2Response, WalletsV2025ControllerGetMeWallet2Responses, WalletsV2025ControllerGetPayoutTransaction2Data, WalletsV2025ControllerGetPayoutTransaction2Error, WalletsV2025ControllerGetPayoutTransaction2Errors, WalletsV2025ControllerGetPayoutTransaction2Response, WalletsV2025ControllerGetPayoutTransaction2Responses, WalletsV2025ControllerGetSignature2Data, WalletsV2025ControllerGetSignature2Error, WalletsV2025ControllerGetSignature2Errors, WalletsV2025ControllerGetSignature2Response, WalletsV2025ControllerGetSignature2Responses, WalletsV2025ControllerGetTransaction2Data, WalletsV2025ControllerGetTransaction2Error, WalletsV2025ControllerGetTransaction2Errors, WalletsV2025ControllerGetTransaction2Response, WalletsV2025ControllerGetTransaction2Responses, WalletsV2025ControllerGetTransactionsWithoutChain2Data, WalletsV2025ControllerGetTransactionsWithoutChain2Error, WalletsV2025ControllerGetTransactionsWithoutChain2Errors, WalletsV2025ControllerGetTransactionsWithoutChain2Response, WalletsV2025ControllerGetTransactionsWithoutChain2Responses, WalletsV2025ControllerGetWalletByLocator2Data, WalletsV2025ControllerGetWalletByLocator2Error, WalletsV2025ControllerGetWalletByLocator2Errors, WalletsV2025ControllerGetWalletByLocator2Response, WalletsV2025ControllerGetWalletByLocator2Responses, WalletsV2025ControllerSubmitApprovals2Data, WalletsV2025ControllerSubmitApprovals2Error, WalletsV2025ControllerSubmitApprovals2Errors, WalletsV2025ControllerSubmitApprovals2Response, WalletsV2025ControllerSubmitApprovals2Responses, WalletsV2025ControllerSubmitMeApprovals2Data, WalletsV2025ControllerSubmitMeApprovals2Error, WalletsV2025ControllerSubmitMeApprovals2Errors, WalletsV2025ControllerSubmitMeApprovals2Response, WalletsV2025ControllerSubmitMeApprovals2Responses, WalletsV2025ControllerSubmitMeSignatureApprovals2Data, WalletsV2025ControllerSubmitMeSignatureApprovals2Error, WalletsV2025ControllerSubmitMeSignatureApprovals2Errors, WalletsV2025ControllerSubmitMeSignatureApprovals2Response, WalletsV2025ControllerSubmitMeSignatureApprovals2Responses, WalletsV2025ControllerSubmitSignatureApprovals2Data, WalletsV2025ControllerSubmitSignatureApprovals2Error, WalletsV2025ControllerSubmitSignatureApprovals2Errors, WalletsV2025ControllerSubmitSignatureApprovals2Response, WalletsV2025ControllerSubmitSignatureApprovals2Responses };
