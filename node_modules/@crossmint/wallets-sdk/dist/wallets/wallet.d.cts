import { ApiClient } from '../api/client.cjs';
import { GetTransactionsResponse, GetTransactionSuccessResponse, Activity, RegisterSignerPasskeyParams, WalletLocator, ApproveSignatureResponse } from '../api/types.cjs';
import { WalletNftsResponseDto, WalletsTransactionV2025ResponseDto } from '../api/gen/types.gen.cjs';
import { WalletOptions, Balances, TransactionInputOptions, UserLocator, Transaction, PrepareOnly, ApproveParams, ApproveResult, DelegatedSigner, ApproveOptions, Signature } from './types.cjs';
import { Chain } from '../chains/chains.cjs';
import { Signer } from '../signers/types.cjs';
import '@crossmint/common-sdk-base';
import 'viem';
import '@solana/web3.js';
import '@crossmint/client-sdk-window';
import '@crossmint/client-signers';
import 'abitype';
import 'ox';

type WalletContructorType<C extends Chain> = {
    chain: C;
    address: string;
    owner?: string;
    signer: Signer;
    options?: WalletOptions;
};
declare class Wallet<C extends Chain> {
    #private;
    chain: C;
    address: string;
    owner?: string;
    signer: Signer;
    constructor(args: WalletContructorType<C>, apiClient: ApiClient);
    protected static getApiClient<C extends Chain>(wallet: Wallet<C>): ApiClient;
    protected static getOptions<C extends Chain>(wallet: Wallet<C>): WalletOptions | undefined;
    protected get apiClient(): ApiClient;
    protected get options(): WalletOptions | undefined;
    /**
     * Get the API client
     * @returns The API client
     * @experimental This API is experimental and may change in the future
     */
    experimental_apiClient(): ApiClient;
    /**
     * Get the wallet balances - always includes USDC and native token (ETH/SOL)
     * @param {string[]} tokens - Additional tokens to request (optional: native token and usdc are always included)
     * @param {Chain[]} chains - The chains (optional)
     * @returns {Promise<Balances>} The balances returns nativeToken, usdc, tokens
     * @throws {Error} If the balances cannot be retrieved
     */
    balances(tokens?: string[], chains?: Chain[]): Promise<Balances>;
    /**
     * Transform the API balance response to the new structure
     * @private
     */
    private transformBalanceResponse;
    /**
     * Get the wallet NFTs
     * @param {Object} params - The parameters
     * @param {number} params.perPage - The number of NFTs per page
     * @param {number} params.page - The page number
     * @param {WalletLocator} [params.locator] - The locator
     * @returns The NFTs
     * @experimental This API is experimental and may change in the future
     */
    experimental_nfts(params: {
        perPage: number;
        page: number;
    }): Promise<WalletNftsResponseDto>;
    /**
     * Get the wallet transactions
     * @returns The transactions
     * @throws {Error} If the transactions cannot be retrieved
     */
    experimental_transactions(): Promise<GetTransactionsResponse>;
    /**
     * Get a transaction by id
     * @returns The transaction
     * @throws {Error} If the transaction cannot be retrieved
     */
    experimental_transaction(transactionId: string): Promise<GetTransactionSuccessResponse>;
    /**
     * Get the wallet activity
     * @returns The activity
     * @experimental This API is experimental and may change in the future
     * @throws {Error} If the activity cannot be retrieved
     */
    experimental_activity(): Promise<Activity>;
    /**
     * Send a token to a wallet or user locator
     * @param {string | UserLocator} to - The recipient (address or user locator)
     * @param {string} token - The token (address or currency symbol)
     * @param {string} amount - The amount to send (decimal units)
     * @param {TransactionInputOptions} options - The options for the transaction
     * @returns {Transaction} The transaction
     */
    send<T extends TransactionInputOptions | undefined = undefined>(to: string | UserLocator, token: string, amount: string, options?: T): Promise<Transaction<T extends PrepareOnly<true> ? true : false>>;
    /**
     * @deprecated Use `approve` instead.
     * Approve a transaction
     * @param params - The parameters
     * @param params.transactionId - The transaction id
     * @param params.options - The options for the transaction
     * @param params.options.experimental_approval - The approval
     * @param params.options.additionalSigners - The additional signers
     * @returns The transaction
     */
    approveTransaction(params: ApproveParams): Promise<Error>;
    /**
     * Approve a transaction or signature
     * @param params - The parameters
     * @param params.transactionId - The transaction id or
     * @param params.signatureId - The signature id
     * @param params.options - The options for the transaction
     * @param params.options.experimental_approval - The approval
     * @param params.options.additionalSigners - The additional signers
     * @returns The transaction or signature
     */
    approve<T extends ApproveParams>(params: T): Promise<ApproveResult<T>>;
    /**
     * Add a delegated signer to the wallet
     * @param signer - The signer. For Solana, it must be a string. For EVM, it can be a string or a passkey.
     */
    addDelegatedSigner(params: {
        signer: string | RegisterSignerPasskeyParams;
    }): Promise<void>;
    delegatedSigners(): Promise<DelegatedSigner[]>;
    protected get walletLocator(): WalletLocator;
    protected get isSolanaWallet(): boolean;
    protected approveTransactionAndWait(transactionId: string, options?: ApproveOptions): Promise<{
        hash: string;
        explorerLink: string;
        transactionId: string;
    }>;
    protected approveSignatureAndWait(signatureId: string, options?: ApproveOptions): Promise<{
        signature: string;
        signatureId: string;
    }>;
    protected approveSignatureInternal(signatureId: string, options?: ApproveOptions): Promise<ApproveSignatureResponse>;
    protected approveTransactionInternal(transactionId: string, options?: ApproveOptions): Promise<WalletsTransactionV2025ResponseDto>;
    private executeApproveTransactionWithErrorHandling;
    private executeApproveSignatureWithErrorHandling;
    protected waitForSignature(signatureId: string): Promise<Signature<false>>;
    protected waitForTransaction(transactionId: string, timeoutMs?: number, { backoffMultiplier, maxBackoffMs, initialBackoffMs, }?: {
        initialBackoffMs?: number;
        backoffMultiplier?: number;
        maxBackoffMs?: number;
    }): Promise<Transaction<false>>;
    protected sleep(ms: number): Promise<unknown>;
}

export { Wallet };
