import{d as O}from"./chunk-NZJHKQ7Z.js";import{c as L,d as P,i as E,m as N,p as x,q as _,r as $,s as W,t as R,u as F,v as I,w as k,x as B}from"./chunk-PSXRNSOE.js";import{a as T,b as A,c,d as b,e as C,f as o}from"./chunk-BW7YYVZE.js";import{isValidAddress as G}from"@crossmint/common-sdk-base";var f,l,J=class{constructor(e,r){b(this,f);b(this,l);let{chain:t,address:n,owner:s,signer:d,options:g}=e;C(this,l,r),this.chain=t,this.address=n,this.owner=s,this.signer=d,C(this,f,g)}static getApiClient(e){return e.apiClient}static getOptions(e){return e.options}get apiClient(){return c(this,l)}get options(){return c(this,f)}experimental_apiClient(){return c(this,l)}balances(e,r){return o(this,null,function*(){let t;switch(this.chain){case"solana":t="sol";break;case"stellar":t="xlm";break;default:t="eth";break}let n=[t,"usdc",...e!=null?e:[]],s=yield c(this,l).getBalance(this.address,{chains:r!=null?r:[this.chain],tokens:n});if("error"in s)throw new Error(`Failed to get balances for wallet: ${JSON.stringify(s.message)}`);return this.transformBalanceResponse(s,t,e)})}transformBalanceResponse(e,r,t){let n=a=>{var m,w,v,y,S;let u=(m=a.chains)==null?void 0:m[this.chain],h=u!=null&&"contractAddress"in u?u.contractAddress:void 0;return{symbol:(w=a.symbol)!=null?w:"",name:(v=a.name)!=null?v:"",amount:(y=a.amount)!=null?y:"0",contractAddress:h,decimals:a.decimals,rawAmount:(S=a.rawAmount)!=null?S:"0"}},s=e.find(a=>a.symbol===r),d=e.find(a=>a.symbol==="usdc"),g=e.filter(a=>a.symbol!==r&&a.symbol!=="usdc"),i=a=>({symbol:a,name:a,amount:"0",contractAddress:void 0,decimals:0,rawAmount:"0"});return{nativeToken:s!=null?n(s):i(r),usdc:d!=null?n(d):i("usdc"),tokens:g.map(n)}}experimental_nfts(e){return o(this,null,function*(){return yield c(this,l).experimental_getNfts(A(T({},e),{chain:this.chain,address:this.address}))})}experimental_transactions(){return o(this,null,function*(){let e=yield c(this,l).getTransactions(this.walletLocator);if("error"in e)throw new Error(`Failed to get transactions: ${JSON.stringify(e.message)}`);return e})}experimental_transaction(e){return o(this,null,function*(){let r=yield c(this,l).getTransaction(this.walletLocator,e);if("error"in r)throw new Error(`Failed to get transaction: ${JSON.stringify(r.error)}`);return r})}experimental_activity(){return o(this,null,function*(){let e=yield this.apiClient.experimental_activity(this.walletLocator,{chain:this.chain});if("error"in e)throw new Error(`Failed to get activity: ${JSON.stringify(e.message)}`);return e})}send(e,r,t,n){return o(this,null,function*(){let s=H(e),d=M(r,this.chain),g=T({recipient:s,amount:t},(n==null?void 0:n.experimental_signer)!=null?{signer:n.experimental_signer}:{}),i=yield c(this,l).send(this.walletLocator,d,g);if("message"in i)throw new $(`Failed to send token: ${JSON.stringify(i.message)}`);return n!=null&&n.experimental_prepareOnly?{hash:void 0,explorerLink:void 0,transactionId:i.id}:yield this.approveTransactionAndWait(i.id)})}approveTransaction(e){return o(this,null,function*(){return console.warn("approveTransaction is deprecated. Use approve instead. This method will be removed in the next major version."),yield this.approve(e)})}approve(e){return o(this,null,function*(){if(e.transactionId!=null)return yield this.approveTransactionAndWait(e.transactionId,e.options);if(e.signatureId!=null)return yield this.approveSignatureAndWait(e.signatureId,e.options);throw new Error("Either transactionId or signatureId must be provided")})}addDelegatedSigner(e){return o(this,null,function*(){var t;let r=yield c(this,l).registerSigner(this.walletLocator,{signer:e.signer,chain:this.chain==="solana"||this.chain==="stellar"?void 0:this.chain});if("error"in r)throw new Error(`Failed to register signer: ${JSON.stringify(r.message)}`);if("transaction"in r&&r.transaction!=null){let n=r.transaction.id;yield this.approveTransactionAndWait(n)}else if("chains"in r){let n=(t=r.chains)==null?void 0:t[this.chain];if((n==null?void 0:n.status)==="awaiting-approval"){yield this.approveSignatureAndWait(n.id);return}if((n==null?void 0:n.status)==="pending"){yield this.waitForSignature(n.id);return}}})}delegatedSigners(){return o(this,null,function*(){var r,t,n;let e=yield c(this,l).getWallet(this.walletLocator);if("error"in e)throw new P(JSON.stringify(e));if(e.type!=="smart"||e.chainType!=="evm"&&e.chainType!=="solana"&&e.chainType!=="stellar")throw new L(`Wallet type ${e.type} not supported`);return(n=(t=(r=e==null?void 0:e.config)==null?void 0:r.delegatedSigners)==null?void 0:t.map(s=>{let d=s.locator.indexOf(":");return{signer:`external-wallet:${d>=0?s.locator.slice(d+1):s.locator}`}}))!=null?n:[]})}get walletLocator(){return c(this,l).isServerSide?this.address:this.chain==="stellar"?"me:stellar:smart":this.chain==="solana"?"me:solana:smart":"me:evm:smart"}get isSolanaWallet(){return this.chain==="solana"}approveTransactionAndWait(e,r){return o(this,null,function*(){return yield this.approveTransactionInternal(e,r),yield this.sleep(1e3),yield this.waitForTransaction(e)})}approveSignatureAndWait(e,r){return o(this,null,function*(){let t=yield this.approveSignatureInternal(e,r);return!("error"in t)&&t.status==="success"&&t.outputSignature!=null?{signature:t.outputSignature,signatureId:e}:(yield this.sleep(1e3),yield this.waitForSignature(e))})}approveSignatureInternal(e,r){return o(this,null,function*(){var i,a;if(this.isSolanaWallet)throw new Error("Approving signatures is only supported for EVM smart wallets");let t=yield c(this,l).getSignature(this.walletLocator,e);if("error"in t)throw new x(JSON.stringify(t));if(this.signer.type==="api-key")return t;if((r==null?void 0:r.experimental_approval)!=null){let u=[r.experimental_approval];return yield this.executeApproveSignatureWithErrorHandling(e,u)}let n=(i=t.approvals)==null?void 0:i.pending;if(n==null)return t;let s=[...(a=r==null?void 0:r.additionalSigners)!=null?a:[],this.signer],g=(yield Promise.all(n.map(u=>{let h=s.find(m=>m.locator()===u.signer.locator);if(h==null)throw new E(`Signer ${u.signer} not found in pending approvals`);return h.signMessage(u.message)}))).map(u=>A(T({},u),{signer:this.signer.locator()}));return yield this.executeApproveSignatureWithErrorHandling(e,g)})}approveTransactionInternal(e,r){return o(this,null,function*(){var i,a,u,h,m;let t=yield c(this,l).getTransaction(this.walletLocator,e);if("error"in t)throw new W(JSON.stringify(t));if(yield(u=(a=(i=c(this,f))==null?void 0:i.experimental_callbacks)==null?void 0:a.onTransactionStart)==null?void 0:u.call(a),this.signer.type==="api-key")return t;if((r==null?void 0:r.experimental_approval)!=null){let w=[r.experimental_approval];return yield this.executeApproveTransactionWithErrorHandling(e,w)}let n=(h=t.approvals)==null?void 0:h.pending;if(n==null)return t;let s=[...(m=r==null?void 0:r.additionalSigners)!=null?m:[],this.signer],g=(yield Promise.all(n.map(w=>{let v=s.find(S=>S.locator()===w.signer.locator);if(v==null)throw new E(`Signer ${w.signer} not found in pending approvals`);let y=t.chainType==="solana"&&"transaction"in t.onChain?t.onChain.transaction:w.message;return v.signTransaction(y)}))).map(w=>A(T({},w),{signer:this.signer.locator()}));return yield this.executeApproveTransactionWithErrorHandling(e,g)})}executeApproveTransactionWithErrorHandling(e,r){return o(this,null,function*(){let t=yield c(this,l).approveTransaction(this.walletLocator,e,{approvals:r});if(t.error)throw new B(JSON.stringify(t));return t})}executeApproveSignatureWithErrorHandling(e,r){return o(this,null,function*(){let t=yield c(this,l).approveSignature(this.walletLocator,e,{approvals:r});if(t.error)throw new _(JSON.stringify(t));return t})}waitForSignature(e){return o(this,null,function*(){let r=null;do if(yield new Promise(t=>setTimeout(t,O)),r=yield c(this,l).getSignature(this.walletLocator,e),"error"in r)throw new x(JSON.stringify(r));while(r===null||r.status==="pending");if(r.status==="failed")throw new N("Signature signing failed");if(!r.outputSignature)throw new x("Signature not available");return{signature:r.outputSignature,signatureId:e}})}waitForTransaction(d){return o(this,arguments,function*(e,r=6e4,{backoffMultiplier:t=1.1,maxBackoffMs:n=2e3,initialBackoffMs:s=O}={}){var u;let g=Date.now(),i;do{if(Date.now()-g>r)throw new R("Transaction confirmation timeout");if(i=yield c(this,l).getTransaction(this.walletLocator,e),i.error)throw new W(JSON.stringify(i));yield this.sleep(s),s=Math.min(s*t,n)}while(i.status==="pending");if(i.status==="failed")throw new F(`Transaction sending failed: ${JSON.stringify(i.error)}`);if(i.status==="awaiting-approval")throw new I("Transaction is awaiting approval. Please submit required approvals before waiting for completion.");let a=i.onChain.txId;if(a==null)throw new k("Transaction hash not found on transaction response");return{hash:a,explorerLink:(u=i.onChain.explorerLink)!=null?u:"",transactionId:i.id}})}sleep(e){return o(this,null,function*(){return new Promise(r=>setTimeout(r,e))})}};f=new WeakMap,l=new WeakMap;function H(p){if(typeof p=="string")return p;if("email"in p)return`email:${p.email}`;if("x"in p)return`x:${p.x}`;if("twitter"in p)return`twitter:${p.twitter}`;if("phone"in p)return`phoneNumber:${p.phone}`;if("userId"in p)return`userId:${p.userId}`;throw new Error("Invalid recipient locator")}function M(p,e){return G(p)?`${e}:${p}`:`${e}:${p.toLowerCase()}`}export{J as a};
