import{a as C}from"./chunk-B4YUFFUB.js";import{a as S}from"./chunk-BHGNJYYE.js";import{a as f}from"./chunk-TGDATYOV.js";import{d as y,f as r}from"./chunk-PSXRNSOE.js";import{a as s,f as c}from"./chunk-BW7YYVZE.js";import{WebAuthnP256 as W}from"ox";var u="When 'delegatedSigners' is provided to a method that may fetch an existing wallet, each specified delegated signer must exist in that wallet's configuration.",w=class{constructor(e){this.apiClient=e}getOrCreateWallet(e){return c(this,null,function*(){if(this.apiClient.isServerSide)throw new r(`getOrCreateWallet can only be called from client-side code.
- Make sure you're running this in the browser (or another client environment), not on your server.
- Use your Crossmint Client API Key (not a server key).`);let n=yield this.apiClient.getWallet(`me:${this.getChainType(e.chain)}:smart`);return n!=null&&!("error"in n)?this.createWalletInstance(n,e):this.createWallet(e)})}getWallet(e,n){return c(this,null,function*(){if(!this.apiClient.isServerSide)throw new r("getWallet is not supported on client side, use getOrCreateWallet instead");let i=yield this.apiClient.getWallet(e);if("error"in i)throw new y(JSON.stringify(i));return this.createWalletInstance(i,n)})}createWallet(e){return c(this,null,function*(){var t,a,l,o;yield(l=(a=(t=e.options)==null?void 0:t.experimental_callbacks)==null?void 0:a.onWalletCreationStart)==null?void 0:l.call(a),this.mutateSignerFromCustomAuth(e,!0);let n=e.signer.type==="passkey"?yield this.createPasskeyAdminSigner(e.signer):e.signer,i=yield this.apiClient.createWallet({type:"smart",chainType:this.getChainType(e.chain),config:s(s({adminSigner:n},e!=null&&e.plugins?{plugins:e.plugins}:{}),e.delegatedSigners!=null?{delegatedSigners:e.delegatedSigners}:{}),owner:(o=e.owner)!=null?o:void 0});if("error"in i)throw new r(JSON.stringify(i));return this.createWalletInstance(i,e)})}createWalletInstance(e,n){this.validateExistingWalletConfig(e,n);let i=this.toInternalSignerConfig(e,n.signer,n.options);return new C({chain:n.chain,address:e.address,owner:e.owner,signer:f(n.chain,i),options:n.options},this.apiClient)}toInternalSignerConfig(e,n,i){var t,a,l,o,d,m;if(!(e.chainType==="evm"||e.chainType==="solana"||e.chainType==="stellar"))throw new r(`Wallet type ${e.chainType} is not supported`);if(n==null&&((t=e.config)==null?void 0:t.adminSigner)==null)throw new r("Signer is required to create a wallet");switch(n.type){case"api-key":{if(((a=e.config)==null?void 0:a.adminSigner.type)!=="api-key")throw new r("API key signer does not match the wallet's signer type");return{type:"api-key",address:e.config.adminSigner.address,locator:e.config.adminSigner.locator}}case"external-wallet":if(((l=e.config)==null?void 0:l.adminSigner.type)!=="external-wallet")throw new r("External wallet signer does not match the wallet's signer type");return s(s({},e.config.adminSigner),n);case"passkey":if(((o=e.config)==null?void 0:o.adminSigner.type)!=="passkey")throw new r("Passkey signer does not match the wallet's signer type");return{type:"passkey",id:e.config.adminSigner.id,name:e.config.adminSigner.name,locator:e.config.adminSigner.locator,onCreatePasskey:n.onCreatePasskey,onSignWithPasskey:n.onSignWithPasskey};case"email":{if(((d=e.config)==null?void 0:d.adminSigner.type)!=="email")throw new r("Email signer does not match the wallet's signer type");let{locator:g,email:h,address:p}=e.config.adminSigner;return{type:"email",email:h,locator:g,address:p,crossmint:this.apiClient.crossmint,onAuthRequired:n.onAuthRequired,clientTEEConnection:i==null?void 0:i.clientTEEConnection}}case"phone":{if(((m=e.config)==null?void 0:m.adminSigner.type)!=="phone")throw new r("Phone signer does not match the wallet's signer type");let{locator:g,phone:h,address:p}=e.config.adminSigner;return{type:"phone",phone:h,locator:g,address:p,crossmint:this.apiClient.crossmint,onAuthRequired:n.onAuthRequired,clientTEEConnection:i==null?void 0:i.clientTEEConnection}}default:throw new Error("Invalid signer type")}}createPasskeyAdminSigner(e){return c(this,null,function*(){var t;if(e.type!=="passkey")throw new Error("Signer is not a passkey");let n=(t=e.name)!=null?t:`Crossmint Wallet ${Date.now()}`,i=e.onCreatePasskey?yield e.onCreatePasskey(n):yield W.createCredential({name:n});return{type:"passkey",id:i.id,name:n,publicKey:{x:i.publicKey.x.toString(),y:i.publicKey.y.toString()}}})}mutateSignerFromCustomAuth(e,n=!1){var t,a;let{experimental_customAuth:i}=this.apiClient.crossmint;e.signer.type==="email"&&(i==null?void 0:i.email)!=null&&(e.signer.email=(t=e.signer.email)!=null?t:i.email),e.signer.type==="phone"&&(i==null?void 0:i.phone)!=null&&(e.signer.phone=(a=e.signer.phone)!=null?a:i.phone),e.signer.type==="external-wallet"&&(i==null?void 0:i.externalWalletSigner)!=null&&(e.signer=n?{type:"external-wallet",address:i.externalWalletSigner.address}:i.externalWalletSigner)}validateExistingWalletConfig(e,n){var a;if(this.mutateSignerFromCustomAuth(n),n.owner!=null&&e.owner!=null&&n.owner!==e.owner)throw new r("Wallet owner does not match existing wallet's linked user");if(n.chain==="solana"&&e.chainType!=="solana"||n.chain!=="solana"&&e.chainType==="solana"||n.chain==="stellar"&&e.chainType!=="stellar"||n.chain!=="stellar"&&e.chainType==="stellar")throw new r(`Wallet chain does not match existing wallet's chain. You must use chain: ${e.chainType}.`);if(e.type!=="smart")return;let i=n.signer,t=(a=e==null?void 0:e.config)==null?void 0:a.adminSigner;if(i!=null&&t!=null){if(i.type!==t.type)throw new r("The wallet signer type provided in the wallet config does not match the existing wallet's adminSigner type");S(i,t)}n.delegatedSigners!=null&&this.validateDelegatedSigners(e,n.delegatedSigners)}validateDelegatedSigners(e,n){var t;let i=(t=e==null?void 0:e.config)==null?void 0:t.delegatedSigners;if(n.length!==0){if(i==null||i.length===0)throw new r(`${n.length} delegated signer(s) specified, but wallet "${e.address}" has no delegated signers. ${u}`);for(let a of n)if(i.find(o=>o.locator===a.signer)==null){let o=i.map(d=>d.locator).join(", ");throw new r(`Delegated signer '${a.signer}' does not exist in wallet "${e.address}". Available delegated signers: ${o}. ${u}`)}}}getChainType(e){return e==="solana"?"solana":e==="stellar"?"stellar":"evm"}};export{w as a};
