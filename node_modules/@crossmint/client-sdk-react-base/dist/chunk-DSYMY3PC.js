import{a as A}from"./chunk-B3EC7QUJ.js";import{a as T,b as I,c as v}from"./chunk-22GIA4MK.js";import{createContext as re,useCallback as ie,useEffect as V,useMemo as se,useState as M}from"react";import{CrossmintWallets as le}from"@crossmint/wallets-sdk";import{useContext as X}from"react";function fe(){let i=X(U);if(!i)throw new Error("useWallet must be used within CrossmintWalletProvider");return i}import{useContext as ne}from"react";import{createContext as G,useCallback as E,useContext as Q,useEffect as O,useMemo as Y,useRef as Z,useState as k}from"react";import{CrossmintAuth as $,getCookie as L}from"@crossmint/client-sdk-auth";import{SESSION_PREFIX as K}from"@crossmint/common-sdk-auth";import{jsx as te}from"react/jsx-runtime";var S=G({crossmintAuth:void 0,logout:()=>{},status:"initializing",getUser:()=>{},login:()=>{}});function _(){let i=Q(S);if(i==null)throw new Error("useCrossmintAuthBase must be used within CrossmintAuthBaseProvider");return i}function ee({children:i,onLoginSuccess:s,refreshRoute:u,logoutRoute:p,storageProvider:o}){let{crossmint:h}=A("CrossmintAuthBaseProvider must be used within CrossmintProvider"),[t,d]=k(void 0),[n,l]=k(void 0),[f,C]=k(!1),g=Z(null);O(()=>{if(!g.current)try{g.current=$.from(h,{callbacks:{onLogout:()=>{d(void 0),l(void 0)},onTokenRefresh:r=>{d(r.user),l(r.jwt)}},refreshRoute:u,logoutRoute:p,storageProvider:o})}catch(r){console.error("Failed to initialize CrossmintAuth:",r)}},[h,u,p,o]);let e=g.current,c=E(()=>{s==null||s()},[s]);O(()=>{var r;if(n==null)if(o)(r=o.get)==null||r.call(o,K).then(a=>{a!=null&&l(a)}).finally(()=>{C(!0)});else{try{let a=L(K);l(a)}catch(a){console.error("Failed to get cookie:",a)}C(!0)}else C(!0)},[n,o]),O(()=>{n!=null&&c()},[n,c]);let y=E(()=>{e==null||e.logout()},[e]),x=E(()=>v(this,null,function*(){if(n==null){console.log("User not logged in");return}let r=yield e==null?void 0:e.getUser();return d(r),r}),[n,e]),w=E(()=>f?n!=null?"logged-in":"logged-out":"initializing",[n,f]),B=Y(()=>({crossmintAuth:e,logout:y,jwt:n,user:t,status:w(),getUser:x,login:()=>{}}),[e,y,n,t,f,x,w]);return te(S.Provider,{value:B,children:i})}function oe(){let i=ne(S);if(i==null)throw new Error("useCrossmintAuth must be used within a CrossmintAuthProvider");return i}var qe=oe;import{jsx as ue}from"react/jsx-runtime";var U=re({wallet:void 0,status:"not-loaded",getOrCreateWallet:()=>Promise.resolve(void 0),onAuthRequired:void 0,clientTEEConnection:void 0});function je({children:i,createOnLogin:s,callbacks:u,onAuthRequired:p,clientTEEConnection:o}){let{crossmint:h,experimental_customAuth:t}=A("CrossmintWalletBaseProvider must be used within CrossmintProvider"),[d,n]=M(void 0),[l,f]=M("not-loaded"),C=ie(e=>v(this,null,function*(){var c,y,x,w,B,r,a,z,N,H,j,D;if(!((t==null?void 0:t.jwt)==null||l==="in-progress")){if(d!=null)return d;try{f("in-progress");let R=le.from(h),q=(y=(c=e.options)==null?void 0:c.experimental_callbacks)==null?void 0:y.onWalletCreationStart,b=(w=(x=e.options)==null?void 0:x.experimental_callbacks)==null?void 0:w.onTransactionStart;if(((B=e==null?void 0:e.signer)==null?void 0:B.type)==="email"){let m=(r=e.signer.email)!=null?r:t==null?void 0:t.email,F=(a=e.signer.onAuthRequired)!=null?a:p;if(m==null)throw new Error("Email not found in experimental_customAuth or signer. Please set email in experimental_customAuth or signer.");e.signer=I(T({},e.signer),{email:m,onAuthRequired:F})}if(((z=e==null?void 0:e.signer)==null?void 0:z.type)==="phone"){let m=(N=e.signer.phone)!=null?N:t==null?void 0:t.phone,F=(H=e.signer.onAuthRequired)!=null?H:p;if(m==null)throw new Error("Phone not found in signer. Please set phone in signer.");e.signer=I(T({},e.signer),{phone:m,onAuthRequired:F})}if(((j=e==null?void 0:e.signer)==null?void 0:j.type)==="external-wallet"){let m=((D=e.signer)==null?void 0:D.address)!=null?e.signer:t.externalWalletSigner;if(m==null)throw new Error("External wallet config not found in experimental_customAuth or signer. Please set it in experimental_customAuth or signer.");e.signer=m}let J=yield R.getOrCreateWallet({chain:e.chain,signer:e.signer,owner:e.owner,plugins:e.plugins,delegatedSigners:e.delegatedSigners,options:{clientTEEConnection:o==null?void 0:o(),experimental_callbacks:{onWalletCreationStart:q!=null?q:u==null?void 0:u.onWalletCreationStart,onTransactionStart:b!=null?b:u==null?void 0:u.onTransactionStart}}});return n(J),f("loaded"),J}catch(R){console.error("Failed to create wallet:",R),n(void 0),f("error");return}}}),[h,t]);V(()=>{if(s!=null){if(s.signer.type==="email"&&(t==null?void 0:t.email)==null||s.signer.type==="external-wallet"&&(t==null?void 0:t.externalWalletSigner)==null&&s.signer.address==null)return;C(s)}},[s,C,t==null?void 0:t.email,t==null?void 0:t.externalWalletSigner]),V(()=>{(t==null?void 0:t.jwt)==null&&l!=="not-loaded"&&(f("not-loaded"),n(void 0))},[t==null?void 0:t.jwt,l]);let g=se(()=>({wallet:d,status:l,getOrCreateWallet:C,onAuthRequired:p,clientTEEConnection:o}),[C,d,l,p,o]);return ue(U.Provider,{value:g,children:i})}export{U as a,je as b,fe as c,S as d,_ as e,ee as f,oe as g,qe as h};
