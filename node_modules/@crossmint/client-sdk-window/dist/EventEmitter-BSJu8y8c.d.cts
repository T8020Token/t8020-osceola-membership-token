import { z } from 'zod';

type SimpleMessageEvent = {
    type: string;
    data: {
        event: string;
        data: object;
    };
};
interface Transport<OutgoingEvents extends EventMap = EventMap> {
    send<K extends keyof OutgoingEvents>(message: {
        event: K;
        data: z.infer<OutgoingEvents[K]>;
    }): void;
    addMessageListener(listener: (event: SimpleMessageEvent | MessageEvent) => void): string;
    removeMessageListener(id: string): void;
}

type EventMap = Record<string, z.ZodTypeAny>;
interface EventEmitterOptions<IncomingEvents extends EventMap = EventMap, OutgoingEvents extends EventMap = EventMap> {
    incomingEvents?: IncomingEvents;
    outgoingEvents?: OutgoingEvents;
}
interface SendActionOptions<IncomingEvents extends EventMap, R extends keyof IncomingEvents> {
    timeoutMs?: number;
    intervalMs?: number;
    maxRetries?: number;
    condition?: (data: z.infer<IncomingEvents[R]>) => boolean;
}
type SendActionArgs<IncomingEvents extends EventMap, OutgoingEvents extends EventMap, K extends keyof OutgoingEvents, R extends keyof IncomingEvents> = {
    event: K;
    data: z.infer<OutgoingEvents[K]>;
    responseEvent: R;
    options?: SendActionOptions<IncomingEvents, R>;
};
interface OnActionOptions<OutgoingEvents extends EventMap, R extends keyof OutgoingEvents> {
    timeoutMs?: number;
    condition?: (data: z.infer<OutgoingEvents[R]>) => boolean;
}
type OnActionArgs<IncomingEvents extends EventMap, OutgoingEvents extends EventMap, K extends keyof IncomingEvents, R extends keyof OutgoingEvents> = {
    event: K;
    responseEvent: R;
    callback: (data: z.infer<IncomingEvents[K]>) => z.infer<OutgoingEvents[R]>;
    options?: OnActionOptions<OutgoingEvents, R>;
} | {
    event: K;
    options?: OnActionOptions<OutgoingEvents, R>;
};
declare class EventEmitter<IncomingEvents extends EventMap, OutgoingEvents extends EventMap> {
    protected transport: Transport<OutgoingEvents>;
    incomingEvents: IncomingEvents;
    outgoingEvents: OutgoingEvents;
    constructor(transport: Transport<OutgoingEvents>, incomingEvents: IncomingEvents, outgoingEvents: OutgoingEvents);
    send<K extends keyof OutgoingEvents>(event: K, data: z.infer<OutgoingEvents[K]>): void;
    on<K extends keyof IncomingEvents>(event: K, callback: (data: z.infer<IncomingEvents[K]>) => void): string;
    sendAction<K extends keyof OutgoingEvents, R extends keyof IncomingEvents>({ event, data, responseEvent, options, }: SendActionArgs<IncomingEvents, OutgoingEvents, K, R>): Promise<z.infer<IncomingEvents[R]>>;
    onAction<K extends keyof IncomingEvents, R extends keyof OutgoingEvents>({ event, options, ...params }: OnActionArgs<IncomingEvents, OutgoingEvents, K, R>): Promise<z.infer<IncomingEvents[K]>>;
    off(id: string): void;
}

export { type EventMap as E, type OnActionOptions as O, type SimpleMessageEvent as S, type Transport as T, EventEmitter as a, type EventEmitterOptions as b, type SendActionOptions as c, type SendActionArgs as d, type OnActionArgs as e };
