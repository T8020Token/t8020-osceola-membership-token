import{z as e}from"zod";var n=e.enum(["secp256k1","ed25519"]).describe("Type of cryptographic key"),l=Object.values(n.options),r=e.enum(["base58","base64","hex"]).describe("Encoding format for the key or data"),m=Object.values(r.options),i=e.object({bytes:e.string().describe("The encoded public key value"),encoding:r.describe("The encoding format of the public key payload"),keyType:n.describe("The cryptographic algorithm of the public key")}),d=e.object({bytes:e.string().describe("The encoded signature value"),encoding:r.describe("The encoding format of the signature payload")}),p=e.record(n,i.omit({keyType:!0})),c=e.object({signerStatus:e.enum(["ready"]).describe("Current status of the signer"),publicKeys:p.describe("The public keys of the created signer")}),a=e.object({signerStatus:e.enum(["new-device"]).describe("Current status of the signer")}),o=e.object({authData:e.object({jwt:e.string().describe("JSON Web Token for authentication"),apiKey:e.string().describe("API key for authorization")}).describe("Authentication data for the request")}),b=e.object({encryptedOtp:e.string().describe("Encrypted one-time password")}),y=e.object({status:e.literal("error"),error:e.string(),code:e.string().optional(),data:e.any().optional().describe("Optional additional error data")}),t=s=>y.or(e.object({status:e.literal("success")}).and(s)),f={request:e.object({challenge:e.string().describe("Challenge string for attestation verification")}),response:t(e.object({attestationDocument:e.record(e.string(),e.any()).describe("Document containing the quote")}))},S={request:o.extend({data:e.object({authId:e.string().describe("Authentication identifier for the signer")}).describe("Data needed to create a new signer")}),response:t(e.union([c,a]))},T={request:o.extend({data:e.object({onboardingAuthentication:b}).describe("Data needed for encrypted OTP verification")}),response:t(c)},j={request:o.extend({data:e.object({keyType:n.describe("Type of cryptographic key to retrieve")}).describe("Data specifying which public key to retrieve")}),response:t(e.object({publicKey:i.describe("The requested public key")}))},k={request:o,response:t(e.union([c,a]))},x={request:o.extend({data:e.object({keyType:n.describe("Type of cryptographic key to use for signing"),bytes:e.string().describe("Data to be signed, in encoded format"),encoding:r.describe("Encoding of the data to be signed")}).describe("Data needed to create a signature")}),response:t(e.object({signature:d.describe("The generated signature"),publicKey:i.describe("The public key that signed the data")}))},E={request:o.extend({data:e.object({scheme:e.union([e.literal("ed25519"),e.literal("secp256k1")]).describe("The cryptographic scheme to use"),encoding:e.union([e.literal("base58"),e.literal("hex"),e.literal("strkey")]).describe("Encoding format for the private key")}).describe("Data needed to export the signer")}),response:t(e.object({}))};export{l as a,m as b,f as c,S as d,T as e,j as f,k as g,x as h,E as i};
