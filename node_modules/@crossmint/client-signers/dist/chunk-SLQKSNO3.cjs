"use strict";Object.defineProperty(exports, "__esModule", {value: true});var _zod = require('zod');var n=_zod.z.enum(["secp256k1","ed25519"]).describe("Type of cryptographic key"),g= exports.a =Object.values(n.options),r=_zod.z.enum(["base58","base64","hex"]).describe("Encoding format for the key or data"),l= exports.b =Object.values(r.options),i=_zod.z.object({bytes:_zod.z.string().describe("The encoded public key value"),encoding:r.describe("The encoding format of the public key payload"),keyType:n.describe("The cryptographic algorithm of the public key")}),d=_zod.z.object({bytes:_zod.z.string().describe("The encoded signature value"),encoding:r.describe("The encoding format of the signature payload")}),p=_zod.z.record(n,i.omit({keyType:!0})),c=_zod.z.object({signerStatus:_zod.z.enum(["ready"]).describe("Current status of the signer"),publicKeys:p.describe("The public keys of the created signer")}),a=_zod.z.object({signerStatus:_zod.z.enum(["new-device"]).describe("Current status of the signer")}),o=_zod.z.object({authData:_zod.z.object({jwt:_zod.z.string().describe("JSON Web Token for authentication"),apiKey:_zod.z.string().describe("API key for authorization")}).describe("Authentication data for the request")}),b=_zod.z.object({encryptedOtp:_zod.z.string().describe("Encrypted one-time password")}),y=_zod.z.object({status:_zod.z.literal("error"),error:_zod.z.string(),code:_zod.z.string().optional(),data:_zod.z.any().optional().describe("Optional additional error data")}),t=s=>y.or(_zod.z.object({status:_zod.z.literal("success")}).and(s)),m= exports.c ={request:_zod.z.object({challenge:_zod.z.string().describe("Challenge string for attestation verification")}),response:t(_zod.z.object({attestationDocument:_zod.z.record(_zod.z.string(),_zod.z.any()).describe("Document containing the quote")}))},f= exports.d ={request:o.extend({data:_zod.z.object({authId:_zod.z.string().describe("Authentication identifier for the signer")}).describe("Data needed to create a new signer")}),response:t(_zod.z.union([c,a]))},S= exports.e ={request:o.extend({data:_zod.z.object({onboardingAuthentication:b}).describe("Data needed for encrypted OTP verification")}),response:t(c)},T= exports.f ={request:o.extend({data:_zod.z.object({keyType:n.describe("Type of cryptographic key to retrieve")}).describe("Data specifying which public key to retrieve")}),response:t(_zod.z.object({publicKey:i.describe("The requested public key")}))},j= exports.g ={request:o,response:t(_zod.z.union([c,a]))},k= exports.h ={request:o.extend({data:_zod.z.object({keyType:n.describe("Type of cryptographic key to use for signing"),bytes:_zod.z.string().describe("Data to be signed, in encoded format"),encoding:r.describe("Encoding of the data to be signed")}).describe("Data needed to create a signature")}),response:t(_zod.z.object({signature:d.describe("The generated signature"),publicKey:i.describe("The public key that signed the data")}))},x= exports.i ={request:o.extend({data:_zod.z.object({scheme:_zod.z.union([_zod.z.literal("ed25519"),_zod.z.literal("secp256k1")]).describe("The cryptographic scheme to use"),encoding:_zod.z.union([_zod.z.literal("base58"),_zod.z.literal("hex"),_zod.z.literal("strkey")]).describe("Encoding format for the private key")}).describe("Data needed to export the signer")}),response:t(_zod.z.object({}))};exports.a = g; exports.b = l; exports.c = m; exports.d = f; exports.e = S; exports.f = T; exports.g = j; exports.h = k; exports.i = x;
